<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAD 스타일 평면도 편집기</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            font-family: 'Malgun Gothic', sans-serif;
            background-color: #f0f0f0;
            overflow: hidden; /* 전체 페이지 스크롤 방지 */
        }

        .container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: white;
            box-sizing: border-box;
            padding: 10px;
        }
        
        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            flex-shrink: 0; /* 툴바 높이 고정 */
        }
        
        .tool-group {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        
        .tool-group h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }
        
        button {
            padding: 8px 15px;
            border: 1px solid #ddd;
            background-color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 2px;
            position: relative;
        }
        
        button:hover {
            background-color: #e0e0e0;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button.active {
            background-color: #4CAF50;
            color: white;
        }
        
        .icon-btn {
            width: 50px;
            height: 50px;
            padding: 5px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        
        .icon-btn svg {
            width: 100%;
            height: 100%;
        }
        
        .icon-btn span {
            font-size: 10px;
            margin-top: 2px;
        }

        .main-content {
            display: flex;
            gap: 10px;
            flex-grow: 1; /* 남은 세로 공간을 모두 차지 */
            overflow: hidden; /* 내부 요소가 넘치지 않도록 */
        }

        #canvas-container {
            flex-grow: 1; /* 남은 가로 공간을 모두 차지 */
            border: 2px solid #ddd;
            border-radius: 4px;
            background-color: white;
            position: relative;
            overflow: hidden; 
        }

        #object-panel {
            width: 240px;
            flex-shrink: 0; /* 너비 고정 */
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
        }

        #object-panel-header {
            padding: 10px;
            font-weight: bold;
            border-bottom: 1px solid #ddd;
            background-color: #f0f0f0;
        }

        #object-panel-list {
            list-style: none;
            margin: 0;
            padding: 0;
            overflow-y: auto;
            flex-grow: 1;
        }

        #object-panel-list li {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #object-panel-list li:hover {
            background-color: #e0e0e0;
        }
        
        #object-panel-list li.selected {
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
        }
        
        .size-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            display: none;
            z-index: 10;
        }
        
        .size-controls.show { display: block; }
        
        .size-controls label { display: block; margin-bottom: 5px; font-size: 12px; }
        .size-controls input { width: 60px; margin-left: 5px; }
        
        .stroke-control {
            margin-top: 10px;
            padding: 5px;
            background-color: #f5f5f5;
            border-radius: 3px;
        }
        
        .stroke-control label {
            font-size: 12px;
            font-weight: bold;
        }
        
        .stroke-control input[type="number"] {
            width: 50px;
            margin: 0 5px;
        }
        
        .info { 
            margin-top: 10px; 
            padding: 0 15px 15px 15px; 
            background-color: #e8f4f8; 
            border-radius: 4px; 
            font-size: 14px; 
            flex-shrink: 0;
            overflow: hidden;
            transition: all 0.3s ease-out;
        }
        .info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 12px 0;
        }
        .toggle-icon {
            font-size: 12px;
            transition: transform 0.3s;
        }
        .info.collapsed {
            padding-top: 0;
            padding-bottom: 0;
        }
        .info.collapsed > ul {
            display: none;
        }
        .info.collapsed .toggle-icon {
             transform: rotate(-90deg);
        }

        .shortcut { color: #666; font-size: 11px; margin-left: 5px; }
        
        .history-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 12px;
            color: #666;
            z-index: 10;
        }

        #context-menu {
            position: absolute;
            display: none;
            background-color: white;
            border: 1px solid #ddd;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border-radius: 4px;
            z-index: 1000;
            padding: 5px 0;
        }
        #context-menu button {
            display: block;
            width: 100%;
            padding: 8px 20px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
        }
        #context-menu button:hover {
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="toolbar">
            <div class="tool-group">
                <h3>기본 도구</h3>
                <button id="select-mode" class="active">선택<span class="shortcut">V</span></button>
                <button id="wall-mode">벽<span class="shortcut">A</span></button>
                <button id="rect-mode">사각형<span class="shortcut">R</span></button>
                <button id="text-mode">텍스트</button>
                <button id="delete-btn">삭제<span class="shortcut">Backspace</span></button>
            </div>
            
            <div class="tool-group">
                <h3>편집</h3>
                <button id="copy-btn" disabled>복사<span class="shortcut">Ctrl+C</span></button>
                <button id="paste-btn" disabled>붙여넣기<span class="shortcut">Ctrl+V</span></button>
                <button id="undo-btn" disabled>실행취소<span class="shortcut">Ctrl+Z</span></button>
                <button id="redo-btn" disabled>다시실행<span class="shortcut">Ctrl+Y</span></button>
            </div>
            
            <div class="tool-group">
                <h3>선 스타일</h3>
                <div class="stroke-control">
                    <label>선 두께: 
                        <input type="number" id="default-stroke-width" min="1" max="20" value="2" step="1">px
                    </label>
                </div>
            </div>
            
            <div class="tool-group">
                <h3>건축 요소</h3>
                <button id="door-left-btn" class="icon-btn" title="왼쪽 여닫이문" draggable="true">
                    <svg xmlns="http://www.w3.org/2000/svg" width="55" height="49" fill="none" viewBox="0 0 55 49">
                      <g clip-path="url(#a-1)"><path stroke="#000" stroke-width="1.3" d="M7 41.6H1v6h6v-6Zm47 0h-6v6h6v-6Zm-6 0H7v6h41v-6ZM7 1v45"/><path stroke="#000" stroke-width="1.3" d="M7 1.6a41 41 0 0 1 41 41"/><path stroke="#000" d="M7 45.1h41"/></g>
                      <defs><clipPath id="a-1"><path fill="#fff" d="M0 0h55v49H0z"/></clipPath></defs>
                    </svg>
                </button>
                <button id="door-right-btn" class="icon-btn" title="오른쪽 여닫이문" draggable="true">
                    <svg xmlns="http://www.w3.org/2000/svg" width="55" height="48" fill="none" viewBox="0 0 55 48">
                      <g clip-path="url(#a-2)"><path stroke="#000" stroke-width="1.3" d="M48 41h6v6h-6v-6ZM1 41h6v6H1v-6Zm6 0h41v6H7v-6ZM48 .4v45"/><path stroke="#000" stroke-width="1.3" d="M48 1A41 41 0 0 0 7 42"/><path stroke="#000" d="M48 44.5H7"/></g>
                      <defs><clipPath id="a-2"><path fill="#fff" d="M55 0H0v48h55z"/></clipPath></defs>
                    </svg>
                </button>
                 <button id="window-left-btn" class="icon-btn" title="왼쪽 창문" draggable="true">
                    <svg xmlns="http://www.w3.org/2000/svg" width="62" height="21" fill="none" viewBox="0 0 62 21">
                      <g clip-path="url(#a-3)"><path stroke="#000" stroke-width="1.3" d="M1 1h60m0 0H1v10h60V1Z"/><path fill="#000" d="m13 17 6.5-3.753v7.506L13 17Zm31 0v.65H18.85v-1.3H44V17Z"/></g>
                      <defs><clipPath id="a-3"><path fill="#fff" d="M0 0h62v21H0z"/></clipPath></defs>
                    </svg>
                </button>
                 <button id="window-right-btn" class="icon-btn" title="오른쪽 창문" draggable="true">
                    <svg xmlns="http://www.w3.org/2000/svg" width="62" height="21" fill="none" viewBox="0 0 62 21">
                      <g clip-path="url(#a-4)"><path stroke="#000" stroke-width="1.3" d="M1 1h60m0 0H1v10h60V1Z"/><path fill="#000" d="m54 17-6.5-3.753v7.506L54 17Zm-31 0v.65h25.15v-1.3H23V17Z"/></g>
                      <defs><clipPath id="a-4"><path fill="#fff" d="M0 0h62v21H0z"/></clipPath></defs>
                    </svg>
                </button>
                 <button id="window-both-btn" class="icon-btn" title="양쪽 창문" draggable="true">
                    <svg xmlns="http://www.w3.org/2000/svg" width="66" height="21" fill="none" viewBox="0 0 66 21">
                      <g clip-path="url(#a-5)"><path stroke="#000" stroke-width="1.3" d="M3 1h60m0 0H3v10h60V1Z"/><path fill="#000" d="m66 17-6.5-3.753v7.506L66 17Zm-31 0v.65h25.15v-1.3H35V17ZM0 17l6.5-3.753v7.506L0 17Zm31 0v.65H5.85v-1.3H31V17Z"/></g>
                      <defs><clipPath id="a-5"><path fill="#fff" d="M0 0h66v21H0z"/></clipPath></defs>
                    </svg>
                </button>
                <button id="door-double-btn" class="icon-btn" title="양개형 여닫이문" draggable="true">
                    <svg xmlns="http://www.w3.org/2000/svg" width="96" height="48" fill="none" viewBox="0 0 96 48">
                      <g clip-path="url(#a-6)"><path stroke="#000" stroke-width="1.3" d="M7 41H1v6h6v-6Zm47 0h-6v6h6v-6Zm-6 0H7v6h41v-6ZM7 .4v45"/><path stroke="#000" stroke-width="1.3" d="M7 1a41 41 0 0 1 41 41"/><path stroke="#000" d="M7 44.5h41"/><path stroke="#000" stroke-width="1.3" d="M89 41h6v6h-6v-6Zm-47 0h6v6h-6v-6Zm6 0h41v6H48v-6ZM89 .4v45"/><path stroke="#000" stroke-width="1.3" d="M89 1a41 41 0 0 0-41 41"/><path stroke="#000" d="M89 44.5H48"/></g>
                      <defs><clipPath id="a-6"><path fill="#fff" d="M0 0h96v48H0z"/></clipPath></defs>
                    </svg>
                </button>
            </div>

            <div class="tool-group">
                <h3>파일</h3>
                <button id="save-btn">저장</button>
                <button id="load-btn">불러오기</button>
                <button id="export-btn">이미지 내보내기</button>
                <button id="clear-btn">전체 삭제</button>
            </div>
            
            <div class="tool-group">
                <h3>배경 이미지</h3>
                <button id="bg-image-btn">이미지 불러오기</button>
                <button id="bg-clear-btn" disabled>이미지 제거</button>
                <div style="margin-top: 10px; display: none;" id="opacity-control">
                    <label style="font-size: 12px;">불투명도: 
                        <input type="range" id="bg-opacity" min="10" max="100" value="50" style="width: 100px; vertical-align: middle;">
                        <span id="opacity-value">50%</span>
                    </label>
                </div>
            </div>
            
            <div class="tool-group">
                <h3>보기</h3>
                <button id="grid-btn">격자 표시</button>
            </div>
        </div>
        
        <div class="main-content">
            <div id="canvas-container">
                <canvas id="canvas"></canvas>
                <div class="size-controls" id="size-controls">
                    <label>너비: <input type="number" id="width-input" min="10" step="5"></label>
                    <label>높이: <input type="number" id="height-input" min="10" step="5"></label>
                    <label>각도: <input type="number" id="angle-input" min="0" max="360" step="15"></label>
                    <label id="stroke-width-control" style="display:none;">선 두께: <input type="number" id="stroke-width-input" min="1" max="20" step="1"></label>
                </div>
                <div class="history-counter" id="history-counter"></div>
            </div>

            <div id="object-panel">
                <div id="object-panel-header">객체 목록</div>
                <ul id="object-panel-list">
                    <!-- 객체 목록이 여기에 동적으로 추가됩니다 -->
                </ul>
            </div>
        </div>

        <div class="info collapsed" id="info-banner">
            <div class="info-header" id="info-toggle-btn">
                <strong>사용법</strong>
                <span class="toggle-icon">▼</span>
            </div>
            <ul>
                <li><strong>도구 단축키:</strong> 선택(V), 벽(A), 사각형(R), 삭제(Backspace)</li>
                <li><strong>스냅 기능:</strong> '벽' 도구 사용 시, 다른 객체의 선이나 모서리 근처로 가면 자동으로 달라붙습니다.</li>
                <li><strong>화면 이동:</strong> 스페이스바를 누른 채 드래그 또는 마우스 휠(가운데 버튼)을 클릭한 채 드래그합니다.</li>
                <li><strong>객체 선택:</strong> 캔버스에서 직접 클릭하거나, 우측 '객체 목록' 패널에서 항목을 클릭합니다.</li>
                <li><strong>복사/붙여넣기:</strong> 객체 선택 후 Ctrl+C / Ctrl+V (Mac: Cmd+C / Cmd+V) 또는 편집 메뉴의 버튼을 사용합니다.</li>
                <li><strong>선 두께 조절:</strong> 상단 툴바에서 기본 두께를 설정하거나, 객체 선택 후 나타나는 컨트롤에서 개별 조절합니다.</li>
                <li><strong>건축 요소:</strong> 아이콘 클릭 또는 드래그 앤 드롭으로 삽입. 우클릭 시 '좌우 반전'이 가능합니다.</li>
                <li><strong>확대/축소:</strong> Ctrl(Windows) 또는 Command(Mac) 키를 누른 채 마우스 휠을 돌려 조절합니다.</li>
                <li><strong>크기/회전:</strong> 객체 모서리 드래그. Shift 키를 누르면 정비율 조절/90도 단위 회전이 됩니다.</li>
                <li><strong>실행취소/다시실행:</strong> Ctrl+Z / Ctrl+Y 또는 버튼 클릭.</li>
            </ul>
        </div>
    </div>

    <div id="context-menu">
        <button id="flip-btn">좌우 반전</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script>
        const canvasContainer = document.getElementById('canvas-container');
        const canvasEl = document.getElementById('canvas');

        const canvas = new fabric.Canvas('canvas', { backgroundColor: 'white', selection: true, stopContextMenu: true, fireRightClick: true, uniScaleTransform: true, });

        const history = {
            states: [], currentIndex: -1, maxSize: 50, isRestoring: false,
            saveState() { if (this.isRestoring) return; this.states = this.states.slice(0, this.currentIndex + 1); const state = JSON.stringify(canvas.toJSON(['elementType'])); this.states.push(state); if (this.states.length > this.maxSize) { this.states.shift(); } else { this.currentIndex++; } this.updateButtons(); this.updateCounter(); updateObjectPanel(); },
            undo() { if (this.currentIndex > 0) { this.currentIndex--; this.restore(this.states[this.currentIndex]); } },
            redo() { if (this.currentIndex < this.states.length - 1) { this.currentIndex++; this.restore(this.states[this.currentIndex]); } },
            restore(state) { this.isRestoring = true; const vpt = canvas.viewportTransform; canvas.loadFromJSON(state, () => { canvas.viewportTransform = vpt; canvas.renderAll(); if (showGrid) drawGrid(); updateObjectPanel(); this.isRestoring = false; this.updateButtons(); this.updateCounter(); }); },
            updateButtons() { undoBtn.disabled = this.currentIndex <= 0; redoBtn.disabled = this.currentIndex >= this.states.length - 1; },
            updateCounter() { const counter = document.getElementById('history-counter'); counter.textContent = `${this.currentIndex + 1} / ${this.states.length}`; }
        };

        const gridSize = 20;
        let showGrid = false, currentMode = 'select', isDrawing = false;
        let startX, startY, currentLine = null, selectedObject = null;
        let isPanning = false, lastPosX, lastPosY, spacebarDown = false;
        let backgroundImage = null;
        let defaultStrokeWidth = 2;
        let _clipboard = null;
        
        const snapThreshold = 10;
        let snapIndicator;

        const objectPanelList = document.getElementById('object-panel-list');
        const bgImageBtn = document.getElementById('bg-image-btn'), bgClearBtn = document.getElementById('bg-clear-btn'), bgOpacity = document.getElementById('bg-opacity'), opacityValue = document.getElementById('opacity-value'), opacityControl = document.getElementById('opacity-control');
        const selectBtn = document.getElementById('select-mode'), wallBtn = document.getElementById('wall-mode'), rectBtn = document.getElementById('rect-mode'), textBtn = document.getElementById('text-mode'), deleteBtn = document.getElementById('delete-btn');
        
        const doorLeftBtn = document.getElementById('door-left-btn');
        const doorRightBtn = document.getElementById('door-right-btn');
        const windowLeftBtn = document.getElementById('window-left-btn');
        const windowRightBtn = document.getElementById('window-right-btn');
        const windowBothBtn = document.getElementById('window-both-btn');
        const doorDoubleBtn = document.getElementById('door-double-btn');

        const gridBtn = document.getElementById('grid-btn');
        const copyBtn = document.getElementById('copy-btn');
        const pasteBtn = document.getElementById('paste-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        
        const sizeControls = document.getElementById('size-controls'), widthInput = document.getElementById('width-input'), heightInput = document.getElementById('height-input'), angleInput = document.getElementById('angle-input');
        const defaultStrokeInput = document.getElementById('default-stroke-width');
        const strokeWidthControl = document.getElementById('stroke-width-control');
        const strokeWidthInput = document.getElementById('stroke-width-input');

        defaultStrokeInput.addEventListener('change', (e) => {
            defaultStrokeWidth = parseInt(e.target.value, 10);
        });

        history.saveState();

        canvas.on({ 'object:added': () => { if (!history.isRestoring) history.saveState(); }, 'object:modified': () => history.saveState(), 'object:removed': () => { if (!history.isRestoring) history.saveState(); } });
        
        function createObject(type, x, y, callback) {
            let svgString = '';
            let defaultWidth = 80;
            let elementType = type;

            switch(type) {
                case 'door-left': svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="55" height="49" fill="none" viewBox="0 0 55 49"><g><path stroke="#000" stroke-width="1.3" d="M7 41.6H1v6h6v-6Zm47 0h-6v6h6v-6Zm-6 0H7v6h41v-6ZM7 1v45"/><path stroke="#000" stroke-width="1.3" d="M7 1.6a41 41 0 0 1 41 41"/><path stroke="#000" d="M7 45.1h41"/></g></svg>`; elementType = '왼쪽 여닫이문'; break;
                case 'door-right': svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="55" height="48" fill="none" viewBox="0 0 55 48"><g><path stroke="#000" stroke-width="1.3" d="M48 41h6v6h-6v-6ZM1 41h6v6H1v-6Zm6 0h41v6H7v-6ZM48 .4v45"/><path stroke="#000" stroke-width="1.3" d="M48 1A41 41 0 0 0 7 42"/><path stroke="#000" d="M48 44.5H7"/></g></svg>`; elementType = '오른쪽 여닫이문'; break;
                case 'window-left': svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="62" height="21" fill="none" viewBox="0 0 62 21"><g><path stroke="#000" stroke-width="1.3" d="M1 1h60m0 0H1v10h60V1Z"/><path fill="#000" d="m13 17 6.5-3.753v7.506L13 17Zm31 0v.65H18.85v-1.3H44V17Z"/></g></svg>`; elementType = '왼쪽 창문'; break;
                case 'window-right': svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="62" height="21" fill="none" viewBox="0 0 62 21"><g><path stroke="#000" stroke-width="1.3" d="M1 1h60m0 0H1v10h60V1Z"/><path fill="#000" d="m54 17-6.5-3.753v7.506L54 17Zm-31 0v.65h25.15v-1.3H23V17Z"/></g></svg>`; elementType = '오른쪽 창문'; break;
                case 'window-both': svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="66" height="21" fill="none" viewBox="0 0 66 21"><g><path stroke="#000" stroke-width="1.3" d="M3 1h60m0 0H3v10h60V1Z"/><path fill="#000" d="m66 17-6.5-3.753v7.506L66 17Zm-31 0v.65h25.15v-1.3H35V17ZM0 17l6.5-3.753v7.506L0 17Zm31 0v.65H5.85v-1.3H31V17Z"/></g></svg>`; elementType = '양쪽 창문'; break;
                case 'door-double': svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="96" height="48" fill="none" viewBox="0 0 96 48"><g><path stroke="#000" stroke-width="1.3" d="M7 41H1v6h6v-6Zm47 0h-6v6h6v-6Zm-6 0H7v6h41v-6ZM7 .4v45"/><path stroke="#000" stroke-width="1.3" d="M7 1a41 41 0 0 1 41 41"/><path stroke="#000" d="M7 44.5h41"/><path stroke="#000" stroke-width="1.3" d="M89 41h6v6h-6v-6Zm-47 0h6v6h-6v-6Zm6 0h41v6H48v-6ZM89 .4v45"/><path stroke="#000" stroke-width="1.3" d="M89 1a41 41 0 0 0-41 41"/><path stroke="#000" d="M89 44.5H48"/></g></svg>`; defaultWidth = 120; elementType = '양개형 여닫이문'; break;
                default: callback(null); return;
            }

            fabric.loadSVGFromString(svgString, (objects, options) => {
                objects.forEach(obj => { if (obj.stroke) obj.set('strokeWidth', defaultStrokeWidth); });
                const group = new fabric.Group(objects, { left: x, top: y, originX: 'center', originY: 'center', elementType: elementType });
                group.scaleToWidth(defaultWidth);
                callback(group);
            });
        }
        
        function setMode(mode) { 
            if (snapIndicator) snapIndicator.set({ visible: false });

            if (['wall', 'rect', 'text'].includes(mode)) {
                canvas.discardActiveObject().renderAll();
            }
            
            currentMode = mode; 
            document.querySelectorAll('button.active').forEach(btn => btn.classList.remove('active')); 
            const currentBtn = document.getElementById(mode + '-mode') || document.getElementById(mode + '-btn'); 
            if (currentBtn) currentBtn.classList.add('active'); 
            canvas.selection = mode === 'select'; 
            canvas.forEachObject(obj => { if (!obj.isGridLine) obj.selectable = (mode === 'select'); }); 
            canvas.renderAll(); 
        }

        document.addEventListener('keydown', (e) => { 
            if (e.target.tagName === 'INPUT' || e.repeat) return;
            
            if (e.code === 'Space') {
                e.preventDefault();
                spacebarDown = true;
                if (!isPanning) {
                    canvas.setCursor('grab');
                }
            }

            const isCtrlOrCmd = e.ctrlKey || e.metaKey;

            if (isCtrlOrCmd) {
                if (e.key === 'z' || e.key === 'Z') { e.preventDefault(); history.undo(); } 
                if (e.key === 'y' || e.key === 'Y') { e.preventDefault(); history.redo(); }
                if (e.key === 'c' || e.key === 'C') { e.preventDefault(); copyObject(); }
                if (e.key === 'v' || e.key === 'V') { e.preventDefault(); pasteObject(); }
            } else {
                switch(e.code) {
                    case 'Backspace': e.preventDefault(); deleteSelectedObjects(); break;
                    case 'KeyV': setMode('select'); break;
                    case 'KeyA': setMode('wall'); break;
                    case 'KeyR': setMode('rect'); break;
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                spacebarDown = false;
                if (isPanning && !e.buttons) {
                    isPanning = false;
                    canvas.setCursor('default');
                } else if (!isPanning) {
                    canvas.setCursor('default');
                }
            }
        });

        canvas.on('mouse:wheel', (opt) => { 
            if (opt.e.ctrlKey || opt.e.metaKey) { 
                const delta = opt.e.deltaY; let zoom = canvas.getZoom(); zoom *= 0.999 ** delta; if (zoom > 20) zoom = 20; if (zoom < 0.1) zoom = 0.1; canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom); opt.e.preventDefault(); opt.e.stopPropagation(); 
            } 
        });
        
        const contextMenu = document.getElementById('context-menu');
        const flipBtn = document.getElementById('flip-btn');
        let rightClickedObject = null;

        // ======[업데이트된 코드: 스냅 로직 개선]======
        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function getIntersection(line1, line2) {
            const x1 = line1.p1.x, y1 = line1.p1.y, x2 = line1.p2.x, y2 = line1.p2.y;
            const x3 = line2.p1.x, y3 = line2.p1.y, x4 = line2.p2.x, y4 = line2.p2.y;
            
            const den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (den === 0) return null; // Parallel

            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / den;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / den;

            if (t > 0 && t < 1 && u > 0 && u < 1) {
                return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) };
            }
            return null;
        }

        function findSnapPoint(pointer, drawingLine = null) {
            let snapPoint = null;
            let minDist = snapThreshold;

            if (snapIndicator) snapIndicator.set({ visible: false });

            const objectsToSnap = canvas.getObjects().filter(obj => 
                (obj.type === 'line' || obj.type === 'rect') && obj !== currentLine && !obj.isGridLine
            );
            
            // 1. 꼭짓점 스냅
            for (const obj of objectsToSnap) {
                const points = [];
                if (obj.type === 'line') {
                    points.push(new fabric.Point(obj.x1, obj.y1), new fabric.Point(obj.x2, obj.y2));
                    if (obj.transformMatrix) {
                        points.forEach(p => fabric.util.transformPoint(p, obj.transformMatrix, false));
                    }
                } else if (obj.type === 'rect') {
                    const oCoords = obj.oCoords;
                    points.push(oCoords.tl, oCoords.tr, oCoords.br, oCoords.bl);
                }

                for (const p of points) {
                    const dist = getDistance(pointer, p);
                    if (dist < minDist) {
                        minDist = dist;
                        snapPoint = p;
                    }
                }
            }

            // 2. 교차점 스냅 (벽 그리는 중에만)
            if (drawingLine) {
                 for (const obj of objectsToSnap) {
                    const targetLines = [];
                     if (obj.type === 'line') {
                        const p1 = new fabric.Point(obj.x1, obj.y1);
                        const p2 = new fabric.Point(obj.x2, obj.y2);
                         if (obj.transformMatrix) {
                            fabric.util.transformPoint(p1, obj.transformMatrix, false);
                            fabric.util.transformPoint(p2, obj.transformMatrix, false);
                        }
                        targetLines.push({ p1, p2 });
                    } else if (obj.type === 'rect') {
                        const oCoords = obj.oCoords;
                        targetLines.push({ p1: oCoords.tl, p2: oCoords.tr }, { p1: oCoords.tr, p2: oCoords.br }, { p1: oCoords.br, p2: oCoords.bl }, { p1: oCoords.bl, p2: oCoords.tl });
                    }
                    
                    for (const targetLine of targetLines) {
                        const intersection = getIntersection(drawingLine, targetLine);
                        if (intersection) {
                            const dist = getDistance(pointer, intersection);
                            if (dist < minDist) {
                                minDist = dist;
                                snapPoint = intersection;
                            }
                        }
                    }
                 }
            }
            
            if (snapPoint) {
                if (snapIndicator) {
                    snapIndicator.set({ left: snapPoint.x, top: snapPoint.y, visible: true });
                    canvas.bringToFront(snapIndicator);
                }
            }
            return snapPoint;
        }

        canvas.on('mouse:down', (e) => {
            contextMenu.style.display = 'none';

            if (e.button === 3) {
                const target = e.target;
                if (target && target.isType('group') && target.elementType) {
                    e.e.preventDefault();
                    rightClickedObject = target;
                    contextMenu.style.left = `${e.e.clientX}px`;
                    contextMenu.style.top = `${e.e.clientY}px`;
                    contextMenu.style.display = 'block';
                    return;
                }
            }

            const isMiddleClick = e.e.button === 1;
            const isSpacebarPan = spacebarDown && e.e.button === 0;

            if (isMiddleClick || isSpacebarPan) {
                isPanning = true;
                lastPosX = e.e.clientX;
                lastPosY = e.e.clientY;
                canvas.setCursor('grabbing');
                canvas.discardActiveObject();
                canvas.selection = false;
                canvas.renderAll();
                return;
            }

            if (currentMode === 'select' || isDrawing) return;
            const pointer = canvas.getPointer(e.e);
            const snappedStartPoint = (currentMode === 'wall') ? findSnapPoint(pointer) : null;
            
            startX = snappedStartPoint ? snappedStartPoint.x : pointer.x;
            startY = snappedStartPoint ? snappedStartPoint.y : pointer.y;
            isDrawing = true;
            
            switch(currentMode) {
                case 'wall': 
                    currentLine = new fabric.Line([startX, startY, startX, startY], { stroke: 'black', strokeWidth: defaultStrokeWidth, strokeLineCap: 'square', selectable: false, evented: false });
                    canvas.add(currentLine); 
                    break;
                case 'rect':
                     currentLine = new fabric.Rect({ left: startX, top: startY, width: 0, height: 0, fill: 'transparent', stroke: 'black', strokeWidth: defaultStrokeWidth, selectable: false, evented: false });
                     canvas.add(currentLine);
                     break;
                case 'text': 
                    const text = prompt('텍스트를 입력하세요:'); 
                    if (text) { 
                        const insertedObject = new fabric.Text(text, { left: startX, top: startY, fontSize: 14, fill: 'black' }); 
                        canvas.add(insertedObject); 
                        setMode('select'); 
                        canvas.setActiveObject(insertedObject); 
                    } 
                    isDrawing = false; 
                    break;
                case 'door-left': case 'door-right': case 'window-left': case 'window-right': case 'window-both': case 'door-double':
                    createObject(currentMode, startX, startY, (insertedObject) => {
                        if (insertedObject) { canvas.add(insertedObject); setMode('select'); canvas.setActiveObject(insertedObject); canvas.renderAll(); }
                    });
                    isDrawing = false;
                    break;
            }
        });
        
        flipBtn.addEventListener('click', () => {
            if (rightClickedObject) {
                rightClickedObject.set('flipX', !rightClickedObject.flipX);
                canvas.renderAll();
                history.saveState();
            }
            contextMenu.style.display = 'none';
        });

        window.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target)) {
                contextMenu.style.display = 'none';
            }
        });

        canvas.on('mouse:move', (e) => {
            if (isPanning) { const vpt = canvas.viewportTransform; vpt[4] += e.e.clientX - lastPosX; vpt[5] += e.e.clientY - lastPosY; canvas.requestRenderAll(); lastPosX = e.e.clientX; lastPosY = e.e.clientY; return; }
            if (!isDrawing) {
                if(currentMode === 'wall') findSnapPoint(canvas.getPointer(e.e)); // 그리기 전에도 스냅 지점 미리보기
                return;
            };
            
            const pointer = canvas.getPointer(e.e);
            let endX = pointer.x;
            let endY = pointer.y;
            let snapPoint = null;

            if (currentMode === 'wall') {
                const drawingLine = { p1: {x: startX, y: startY}, p2: pointer };
                snapPoint = findSnapPoint(pointer, drawingLine);
                if (snapPoint) {
                    endX = snapPoint.x;
                    endY = snapPoint.y;
                }
            }
            
            if (e.e.shiftKey && !snapPoint) {
                const dx = Math.abs(endX - startX);
                const dy = Math.abs(endY - startY);
                if (dx > dy) { endY = startY; } else { endX = startX; }
            }

            if (currentMode === 'wall' && currentLine) {
                 currentLine.set({ x2: endX, y2: endY });
            } else if (currentMode === 'rect' && currentLine) { 
                const width = Math.abs(pointer.x - startX); 
                const height = Math.abs(pointer.y - startY); 
                currentLine.set({ left: Math.min(pointer.x, startX), top: Math.min(pointer.y, startY), width: width, height: height }); 
            }
            
            canvas.renderAll();
        });

        canvas.on('mouse:up', (e) => {
            if (snapIndicator) snapIndicator.set({ visible: false });

            if (isPanning) { 
                isPanning = false; 
                canvas.selection = (currentMode === 'select');
                canvas.setCursor(spacebarDown ? 'grab' : 'default'); 
                return; 
            }
            if (!isDrawing) return;
            
            if (currentLine) {
                currentLine.set({selectable: true, evented: true}).setCoords();
                setMode('select'); 
                canvas.setActiveObject(currentLine);
            }
            
            isDrawing = false; 
            currentLine = null;
        });

        function handleRotating(opt) {
            if (opt.e.shiftKey) {
                const target = opt.target;
                const snappedAngle = Math.round(target.angle / 90) * 90;
                target.set('angle', snappedAngle);
            }
            updateSizeControls();
        }

        canvas.on({ 
            'selection:created': (e) => updateSelection(e.selected), 
            'selection:updated': (e) => updateSelection(e.selected), 
            'selection:cleared': () => updateSelection([]), 
            'object:scaling': updateSizeControls,
            'object:rotating': handleRotating
        });

        function updateSelection(selected) { 
            highlightPanelSelection(); 
            selectedObject = selected.length === 1 ? selected[0] : null; 
            
            copyBtn.disabled = !selectedObject;
            
            if (selectedObject) { 
                sizeControls.classList.add('show'); 
                updateSizeControls(); 
                if (selectedObject.type === 'line' || selectedObject.type === 'rect' || selectedObject.isType('group')) {
                    strokeWidthControl.style.display = 'block';
                } else {
                    strokeWidthControl.style.display = 'none';
                }
            } else { 
                sizeControls.classList.remove('show'); 
            } 
        }

        function updateSizeControls() { 
            if (selectedObject) { 
                widthInput.value = Math.round(selectedObject.getScaledWidth()); 
                heightInput.value = Math.round(selectedObject.getScaledHeight()); 
                angleInput.value = Math.round(selectedObject.angle); 
                
                if (selectedObject.type === 'line' || selectedObject.type === 'rect') {
                    strokeWidthInput.value = selectedObject.strokeWidth;
                } else if (selectedObject.isType('group')) {
                    const firstStroked = selectedObject.getObjects().find(o => o.stroke);
                    if (firstStroked) {
                        strokeWidthInput.value = firstStroked.strokeWidth;
                    }
                }
            } 
        }
        widthInput.addEventListener('input', () => { if (selectedObject) { selectedObject.scaleToWidth(parseInt(widthInput.value, 10)); canvas.renderAll(); }});
        heightInput.addEventListener('input', () => { if (selectedObject) { selectedObject.scaleToHeight(parseInt(heightInput.value, 10)); canvas.renderAll(); }});
        angleInput.addEventListener('input', () => { if (selectedObject) { selectedObject.set('angle', parseInt(angleInput.value, 10)).setCoords(); canvas.renderAll(); }});
        
        strokeWidthInput.addEventListener('input', () => {
            if (!selectedObject) return;
            const newWidth = parseInt(strokeWidthInput.value, 10);
            if(isNaN(newWidth) || newWidth < 1) return;

            if (selectedObject.type === 'line' || selectedObject.type === 'rect') {
                selectedObject.set('strokeWidth', newWidth);
            } else if (selectedObject.isType('group')) {
                selectedObject.getObjects().forEach(obj => {
                    if (obj.stroke) {
                        obj.set('strokeWidth', newWidth);
                    }
                });
            }
            canvas.renderAll();
            history.saveState();
        });
        
        selectBtn.addEventListener('click', () => setMode('select')); wallBtn.addEventListener('click', () => setMode('wall')); rectBtn.addEventListener('click', () => setMode('rect')); textBtn.addEventListener('click', () => setMode('text'));
        doorLeftBtn.addEventListener('click', () => setMode('door-left')); doorRightBtn.addEventListener('click', () => setMode('door-right')); windowLeftBtn.addEventListener('click', () => setMode('window-left')); windowRightBtn.addEventListener('click', () => setMode('window-right')); windowBothBtn.addEventListener('click', () => setMode('window-both')); doorDoubleBtn.addEventListener('click', () => setMode('door-double'));
        
        copyBtn.addEventListener('click', copyObject);
        pasteBtn.addEventListener('click', pasteObject);
        undoBtn.addEventListener('click', () => history.undo()); 
        redoBtn.addEventListener('click', () => history.redo()); 
        deleteBtn.addEventListener('click', deleteSelectedObjects);

        function deleteSelectedObjects() { canvas.getActiveObjects().forEach(obj => canvas.remove(obj)); canvas.discardActiveObject().renderAll(); }
        
        function copyObject() {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                activeObject.clone(function(cloned) {
                    _clipboard = cloned;
                    pasteBtn.disabled = false;
                }, ['elementType']);
            }
        }

        function pasteObject() {
            if (!_clipboard) return;

            _clipboard.clone(function(clonedObj) {
                canvas.discardActiveObject();
                
                clonedObj.set({
                    left: clonedObj.left + 15,
                    top: clonedObj.top + 15,
                    evented: true,
                });

                if (clonedObj.isType('group')) {
                    clonedObj.getObjects().forEach(function(obj) {
                        const originalObj = _clipboard.getObjects().find(o => o.type === obj.type);
                        if(originalObj && originalObj.strokeWidth) {
                             obj.set('strokeWidth', originalObj.strokeWidth);
                        }
                    });
                }
                
                canvas.add(clonedObj);
                canvas.setActiveObject(clonedObj);
                canvas.requestRenderAll();
            }, ['elementType']);
        }

        function updateObjectPanel() {
            objectPanelList.innerHTML = '';
            const objects = canvas.getObjects().filter(obj => !obj.isGridLine && obj !== snapIndicator);
            objects.forEach((obj, index) => {
                const li = document.createElement('li');
                let name = obj.elementType || obj.type || '객체';
                if(obj.type === 'text') name = `텍스트: ${obj.text.substring(0, 10)}...`;
                else if(obj.type === 'line') name = `벽 ${index + 1}`;
                else if(obj.type === 'rect') name = `사각형 ${index + 1}`;
                else name = `${name} ${index + 1}`;
                li.textContent = name;
                li.dataset.objectIndex = canvas.getObjects().indexOf(obj); 
                li.addEventListener('click', () => { canvas.discardActiveObject(); canvas.setActiveObject(obj); canvas.renderAll(); });
                objectPanelList.appendChild(li);
            });
            highlightPanelSelection();
        }

        function highlightPanelSelection() {
            const activeObjects = canvas.getActiveObjects();
            const listItems = objectPanelList.querySelectorAll('li');
            listItems.forEach(li => {
                const objIndex = parseInt(li.dataset.objectIndex, 10);
                const obj = canvas.getObjects()[objIndex];
                if (activeObjects.includes(obj)) { li.classList.add('selected'); } else { li.classList.remove('selected'); }
            });
        }

        const draggableElements = ['door-left-btn', 'door-right-btn', 'window-left-btn', 'window-right-btn', 'window-both-btn', 'door-double-btn'];
        draggableElements.forEach(id => { const el = document.getElementById(id); el.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', id.replace('-btn', '')); }); });
        canvasContainer.addEventListener('dragover', (e) => e.preventDefault());
        canvasContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            const type = e.dataTransfer.getData('text/plain');
            const zoom = canvas.getZoom();
            const panX = canvas.viewportTransform[4]; const panY = canvas.viewportTransform[5];
            const centerX = (canvas.width / 2 - panX) / zoom; const centerY = (canvas.height / 2 - panY) / zoom;
            
            createObject(type, centerX, centerY, (newObject) => {
                if (newObject) { canvas.add(newObject); setMode('select'); canvas.setActiveObject(newObject); canvas.renderAll(); }
            });
        });
        
        document.getElementById('clear-btn').addEventListener('click', () => { if (confirm('모든 내용을 삭제하시겠습니까?\n(배경 이미지도 함께 제거됩니다)')) { history.isRestoring = true; canvas.clear(); initSnapIndicator(); canvas.setViewportTransform([1, 0, 0, 1, 0, 0]); canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas)); canvas.backgroundColor = 'white'; backgroundImage = null; bgClearBtn.disabled = true; opacityControl.style.display = 'none'; if (showGrid) drawGrid(); history.isRestoring = false; history.saveState(); } });
        bgImageBtn.addEventListener('click', () => { const input = document.createElement('input'); input.type = 'file'; input.accept = 'image/*'; input.onchange = (e) => { const reader = new FileReader(); reader.onload = (event) => { fabric.Image.fromURL(event.target.result, (img) => { const scale = Math.min(canvas.width / img.width, canvas.height / img.height); img.set({ scaleX: scale, scaleY: scale, opacity: bgOpacity.value / 100 }); canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), { originX: 'left', originY: 'top' }); backgroundImage = img; bgClearBtn.disabled = false; opacityControl.style.display = 'block'; }); }; reader.readAsDataURL(e.target.files[0]); }; input.click(); });
        bgClearBtn.addEventListener('click', () => { canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas)); backgroundImage = null; bgClearBtn.disabled = true; opacityControl.style.display = 'none'; });
        bgOpacity.addEventListener('input', (e) => { const opacity = e.target.value; opacityValue.textContent = opacity + '%'; if (backgroundImage) { backgroundImage.set('opacity', opacity / 100); canvas.renderAll(); } });
        
        function drawGrid() { canvas.getObjects().forEach(o => { if (o.isGridLine) canvas.remove(o) }); const zoom = canvas.getZoom(); const panX = canvas.viewportTransform[4]; const panY = canvas.viewportTransform[5]; for (let i = Math.floor(-panX / (gridSize * zoom)); i * gridSize < canvas.width / zoom; i++) { const x = i * gridSize; const line = new fabric.Line([x, -panY / zoom, x, (canvas.height - panY) / zoom], { stroke: '#e0e0e0', strokeWidth: 1, selectable: false, evented: false, isGridLine: true }); canvas.add(line); } for (let i = Math.floor(-panY / (gridSize * zoom)); i * gridSize < canvas.height / zoom; i++) { const y = i * gridSize; const line = new fabric.Line([-panX / zoom, y, (canvas.width - panX) / zoom, y], { stroke: '#e0e0e0', strokeWidth: 1, selectable: false, evented: false, isGridLine: true }); canvas.add(line); } canvas.getObjects().filter(o => o.isGridLine).forEach(o => canvas.sendToBack(o)); }
        canvas.on('after:render', () => { if (showGrid) drawGrid(); });
        gridBtn.addEventListener('click', () => { showGrid = !showGrid; gridBtn.classList.toggle('active', showGrid); if (!showGrid) { canvas.getObjects().forEach(o => { if(o.isGridLine) canvas.remove(o) }); } canvas.renderAll(); });
        
        document.getElementById('export-btn').addEventListener('click', () => {
            const tempBg = canvas.backgroundImage;
            const doExport = () => {
                const link = document.createElement('a');
                link.download = '평면도.png';
                link.href = canvas.toDataURL({ format: 'png', quality: 1 });
                link.click();
            };

            if (tempBg) {
                canvas.setBackgroundImage(null, () => {
                    doExport();
                    canvas.setBackgroundImage(tempBg, canvas.renderAll.bind(canvas));
                });
            } else {
                doExport();
            }
        });

        document.getElementById('save-btn').addEventListener('click', () => { const data = { version: '2.0', canvas: canvas.toJSON(['elementType']), viewport: canvas.viewportTransform, backgroundImage: backgroundImage ? { src: canvas.backgroundImage._element.src, opacity: backgroundImage.opacity, scaleX: backgroundImage.scaleX, scaleY: backgroundImage.scaleY } : null, defaultStrokeWidth: defaultStrokeWidth }; const blob = new Blob([JSON.stringify(data)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.download = '평면도.json'; link.href = url; link.click(); URL.revokeObjectURL(url); });
        document.getElementById('load-btn').addEventListener('click', () => { const input = document.createElement('input'); input.type = 'file'; input.accept = '.json'; input.onchange = (e) => { const reader = new FileReader(); reader.onload = (event) => { const data = JSON.parse(event.target.result); history.isRestoring = true; canvas.loadFromJSON(data.canvas || data, () => { if (data.viewport) canvas.setViewportTransform(data.viewport); if (data.backgroundImage) { fabric.Image.fromURL(data.backgroundImage.src, (img) => { img.set(data.backgroundImage); canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas)); backgroundImage = img; bgClearBtn.disabled = false; opacityControl.style.display = 'block'; bgOpacity.value = (data.backgroundImage.opacity || 1) * 100; opacityValue.textContent = `${Math.round(bgOpacity.value)}%`; }); } if (data.defaultStrokeWidth) { defaultStrokeWidth = data.defaultStrokeWidth; defaultStrokeInput.value = defaultStrokeWidth; } canvas.renderAll(); history.isRestoring = false; history.saveState(); }); }; reader.readAsText(e.target.files[0]); }; input.click(); });
        
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            canvasEl.width = width;
            canvasEl.height = height;

            canvas.setWidth(width);
            canvas.setHeight(height);
            canvas.renderAll();
        }

        const resizeObserver = new ResizeObserver(entries => {
            resizeCanvas();
        });
        resizeObserver.observe(canvasContainer);
        
        resizeCanvas();

        const infoBanner = document.getElementById('info-banner');
        const infoToggleBtn = document.getElementById('info-toggle-btn');

        infoToggleBtn.addEventListener('click', () => {
            infoBanner.classList.toggle('collapsed');
        });

        function initSnapIndicator() {
             snapIndicator = new fabric.Circle({
                radius: 5,
                fill: 'transparent',
                stroke: 'red',
                strokeWidth: 2,
                originX: 'center',
                originY: 'center',
                selectable: false,
                evented: false,
                visible: false,
            });
            canvas.add(snapIndicator);
        }
        initSnapIndicator();

        setMode('select');
    </script>
</body>
</html>
