<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAD 스타일 평면도 편집기</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Malgun Gothic', sans-serif;
            background-color: #f0f0f0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tool-group {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        
        .tool-group h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }
        
        button {
            padding: 8px 15px;
            border: 1px solid #ddd;
            background-color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 2px;
            position: relative;
        }
        
        button:hover {
            background-color: #e0e0e0;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button.active {
            background-color: #4CAF50;
            color: white;
        }
        
        .icon-btn {
            width: 50px;
            height: 50px;
            padding: 5px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        
        .icon-btn svg {
            width: 30px;
            height: 30px;
        }
        
        .icon-btn span {
            font-size: 10px;
            margin-top: 2px;
        }
        
        #canvas-container {
            border: 2px solid #ddd;
            border-radius: 4px;
            display: inline-block;
            background-color: white;
            position: relative;
            overflow: hidden; /* 캔버스 밖으로 나가는 요소 숨기기 */
        }
        
        .size-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            display: none;
        }
        
        .size-controls.show {
            display: block;
        }
        
        .size-controls label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        .size-controls input {
            width: 60px;
            margin-left: 5px;
        }
        
        .info {
            margin-top: 20px;
            padding: 15px;
            background-color: #e8f4f8;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .grid-toggle {
            margin-left: auto;
        }
        
        .shortcut {
            color: #666;
            font-size: 11px;
            margin-left: 5px;
        }
        
        .history-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CAD 스타일 평면도 편집기</h1>

        <div class="toolbar">
            <div class="tool-group">
                <h3>기본 도구</h3>
                <button id="select-mode" class="active">선택<span class="shortcut">V</span></button>
                <button id="wall-mode">벽</button>
                <button id="rect-mode">사각형</button>
                <button id="text-mode">텍스트</button>
                <button id="delete-btn">삭제<span class="shortcut">Backspace</span></button>
            </div>
            
            <div class="tool-group">
                <h3>편집</h3>
                <button id="undo-btn" disabled>실행취소<span class="shortcut">Ctrl+Z</span></button>
                <button id="redo-btn" disabled>다시실행<span class="shortcut">Ctrl+Y</span></button>
            </div>
            
            <div class="tool-group">
                <h3>건축 요소</h3>
                <button id="door-btn" class="icon-btn" title="문">
                    <svg viewBox="0 0 60 60">
                        <line x1="10" y1="50" x2="50" y2="50" stroke="black" stroke-width="3"/>
                        <path d="M 10 50 Q 30 30, 50 50" stroke="black" stroke-width="2" fill="none"/>
                    </svg>
                </button>
                <button id="window-btn" class="icon-btn" title="창문">
                    <svg viewBox="0 0 60 60">
                        <rect x="10" y="25" width="40" height="10" fill="none" stroke="black" stroke-width="2"/>
                        <line x1="10" y1="30" x2="50" y2="30" stroke="black" stroke-width="1"/>
                    </svg>
                </button>
                <button id="sliding-door-btn" class="icon-btn" title="미닫이문">
                    <svg viewBox="0 0 60 60">
                        <line x1="10" y1="30" x2="50" y2="30" stroke="black" stroke-width="3"/>
                        <rect x="15" y="25" width="15" height="10" fill="none" stroke="black" stroke-width="2"/>
                        <rect x="30" y="25" width="15" height="10" fill="none" stroke="black" stroke-width="2"/>
                    </svg>
                </button>
                <button id="stairs-btn" class="icon-btn" title="계단">
                    <svg viewBox="0 0 60 60">
                        <g>
                            <line x1="10" y1="15" x2="50" y2="15" stroke="black" stroke-width="1"/>
                            <line x1="10" y1="25" x2="50" y2="25" stroke="black" stroke-width="1"/>
                            <line x1="10" y1="35" x2="50" y2="35" stroke="black" stroke-width="1"/>
                            <line x1="10" y1="45" x2="50" y2="45" stroke="black" stroke-width="1"/>
                            <polygon points="25,10 30,20 20,20" fill="black"/>
                        </g>
                    </svg>
                </button>
            </div>
            
            <div class="tool-group">
                <h3>파일</h3>
                <button id="save-btn">저장</button>
                <button id="load-btn">불러오기</button>
                <button id="export-btn">이미지 내보내기</button>
                <button id="clear-btn">전체 삭제</button>
            </div>
            
            <div class="tool-group">
                <h3>배경 이미지</h3>
                <button id="bg-image-btn">이미지 불러오기</button>
                <button id="bg-clear-btn" disabled>이미지 제거</button>
                <div style="margin-top: 10px; display: none;" id="opacity-control">
                    <label style="font-size: 12px;">불투명도: 
                        <input type="range" id="bg-opacity" min="10" max="100" value="50" style="width: 100px; vertical-align: middle;">
                        <span id="opacity-value">50%</span>
                    </label>
                </div>
            </div>
            
            <div class="tool-group grid-toggle">
                <h3>보기</h3>
                <button id="grid-btn">격자 표시</button>
            </div>
        </div>
        
        <div id="canvas-container">
            <canvas id="canvas" width="800" height="600"></canvas>
            <div class="size-controls" id="size-controls">
                <label>너비: <input type="number" id="width-input" min="10" step="5"></label>
                <label>높이: <input type="number" id="height-input" min="10" step="5"></label>
                <label>각도: <input type="number" id="angle-input" min="0" max="360" step="15"></label>
            </div>
            <div class="history-counter" id="history-counter"></div>
        </div>
        
        <div class="info">
            <strong>사용법:</strong>
            <ul>
                <li>배경 이미지: 거래처 도면을 불러와서 위에 따라 그릴 수 있습니다.</li>
                <li>불투명도 조절: 배경 이미지가 너무 진할 때 조절하여 작업을 편하게 합니다.</li>
                <li>확대/축소: Ctrl 키를 누른 채 마우스 휠을 돌려 조절합니다.</li>
                <li>화면 이동: 마우스 휠(가운데 버튼)을 클릭한 상태로 드래그합니다.</li>
                <li>선택 모드: V 키 또는 버튼 클릭. 객체를 클릭/드래그하여 선택, 이동, 회전이 가능합니다.</li>
                <li><strong>크기 조절: 객체 모서리를 드래그하여 조절합니다. Shift 키를 누른 채 드래그하면 정비율로 조절됩니다.</strong></li>
                <li>벽 그리기: 클릭하고 드래그하여 벽을 그립니다. (Shift 누른 채 드래그 시 직선 고정)</li>
                <li>건축 요소: 아이콘을 클릭 후 캔버스에 클릭하여 배치합니다. (배치 후 자동으로 선택 모드 전환)</li>
                <li>객체 삭제: 객체 선택 후 Backspace 키 또는 삭제 버튼 클릭.</li>
                <li>실행취소/다시실행: Ctrl+Z / Ctrl+Y 또는 버튼 클릭.</li>
            </ul>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script>
        // Canvas 초기화
        const canvas = new fabric.Canvas('canvas', {
            backgroundColor: 'white',
            selection: true,
            stopContextMenu: true, 
            fireRightClick: true,
            // ======[업데이트된 코드 1]======
            // Shift 키를 이용한 정비율 크기 조절 활성화
            uniScaleTransform: true,
            // ============================
        });

        // 히스토리 관리
        const history = {
            states: [],
            currentIndex: -1,
            maxSize: 50,
            isRestoring: false,
            
            saveState() {
                if (this.isRestoring) return;
                this.states = this.states.slice(0, this.currentIndex + 1);
                const state = JSON.stringify(canvas.toJSON(['elementType']));
                this.states.push(state);
                if (this.states.length > this.maxSize) {
                    this.states.shift();
                } else {
                    this.currentIndex++;
                }
                this.updateButtons();
                this.updateCounter();
            },
            
            undo() {
                if (this.currentIndex > 0) {
                    this.currentIndex--;
                    this.restore(this.states[this.currentIndex]);
                }
            },
            
            redo() {
                if (this.currentIndex < this.states.length - 1) {
                    this.currentIndex++;
                    this.restore(this.states[this.currentIndex]);
                }
            },
            
            restore(state) {
                this.isRestoring = true;
                const vpt = canvas.viewportTransform;
                canvas.loadFromJSON(state, () => {
                    canvas.viewportTransform = vpt;
                    canvas.renderAll();
                    if (showGrid) drawGrid();
                    this.isRestoring = false;
                    this.updateButtons();
                    this.updateCounter();
                });
            },
            
            updateButtons() {
                undoBtn.disabled = this.currentIndex <= 0;
                redoBtn.disabled = this.currentIndex >= this.states.length - 1;
            },
            
            updateCounter() {
                const counter = document.getElementById('history-counter');
                counter.textContent = `${this.currentIndex + 1} / ${this.states.length}`;
            }
        };

        // 전역 변수들
        const gridSize = 20;
        let showGrid = false;
        let currentMode = 'select';
        let isDrawing = false;
        let startX, startY, currentLine = null, selectedObject = null;
        let isPanning = false, lastPosX, lastPosY;
        let backgroundImage = null;
        
        // DOM 요소들
        const bgImageBtn = document.getElementById('bg-image-btn');
        const bgClearBtn = document.getElementById('bg-clear-btn');
        const bgOpacity = document.getElementById('bg-opacity');
        const opacityValue = document.getElementById('opacity-value');
        const opacityControl = document.getElementById('opacity-control');
        const selectBtn = document.getElementById('select-mode');
        const wallBtn = document.getElementById('wall-mode');
        const rectBtn = document.getElementById('rect-mode');
        const textBtn = document.getElementById('text-mode');
        const deleteBtn = document.getElementById('delete-btn');
        const doorBtn = document.getElementById('door-btn');
        const windowBtn = document.getElementById('window-btn');
        const slidingDoorBtn = document.getElementById('sliding-door-btn');
        const stairsBtn = document.getElementById('stairs-btn');
        const gridBtn = document.getElementById('grid-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const sizeControls = document.getElementById('size-controls');
        const widthInput = document.getElementById('width-input');
        const heightInput = document.getElementById('height-input');
        const angleInput = document.getElementById('angle-input');

        // 초기 상태 저장
        history.saveState();

        // Canvas 이벤트에 히스토리 저장 추가
        canvas.on({
            'object:added': () => { if (!history.isRestoring) history.saveState(); },
            'object:modified': () => history.saveState(),
            'object:removed': () => { if (!history.isRestoring) history.saveState(); }
        });

        // 건축 요소 생성 함수들
        function createDoor(x, y) {
            const doorGroup = new fabric.Group([], { left: x, top: y, originX: 'center', originY: 'center' });
            const frame = new fabric.Rect({ left: -40, top: -3, width: 80, height: 6, fill: 'white', stroke: 'black', strokeWidth: 2 });
            const arc = new fabric.Path('M -40 0 Q -40 -40, 0 -40', { fill: '', stroke: 'black', strokeWidth: 2 });
            doorGroup.addWithUpdate(frame);
            doorGroup.addWithUpdate(arc);
            doorGroup.elementType = 'door';
            return doorGroup;
        }

        function createWindow(x, y) {
            const windowGroup = new fabric.Group([], { left: x, top: y, originX: 'center', originY: 'center' });
            const outerFrame = new fabric.Rect({ left: -30, top: -4, width: 60, height: 8, fill: 'white', stroke: 'black', strokeWidth: 2 });
            const centerLine = new fabric.Line([-30, 0, 30, 0], { stroke: 'black', strokeWidth: 1 });
            windowGroup.addWithUpdate(outerFrame);
            windowGroup.addWithUpdate(centerLine);
            windowGroup.elementType = 'window';
            return windowGroup;
        }

        function createSlidingDoor(x, y) {
            const slidingGroup = new fabric.Group([], { left: x, top: y, originX: 'center', originY: 'center' });
            const rail = new fabric.Line([-40, 0, 40, 0], { stroke: 'black', strokeWidth: 3 });
            const door1 = new fabric.Rect({ left: -35, top: -5, width: 30, height: 10, fill: 'transparent', stroke: 'black', strokeWidth: 2 });
            const door2 = new fabric.Rect({ left: -5, top: -5, width: 30, height: 10, fill: 'transparent', stroke: 'black', strokeWidth: 2 });
            slidingGroup.addWithUpdate(rail);
            slidingGroup.addWithUpdate(door1);
            slidingGroup.addWithUpdate(door2);
            slidingGroup.elementType = 'slidingDoor';
            return slidingGroup;
        }

        function createStairs(x, y) {
            const stairsGroup = new fabric.Group([], { left: x, top: y, originX: 'center', originY: 'center' });
            for (let i = 0; i < 6; i++) {
                stairsGroup.addWithUpdate(new fabric.Line([-30, -25 + i * 10, 30, -25 + i * 10], { stroke: 'black', strokeWidth: 1 }));
            }
            stairsGroup.addWithUpdate(new fabric.Polygon([{x: 0, y: -35}, {x: -5, y: -25}, {x: 5, y: -25}], { fill: 'black' }));
            stairsGroup.elementType = 'stairs';
            return stairsGroup;
        }
        
        // 모드 변경 함수
        function setMode(mode) {
            currentMode = mode;
            document.querySelectorAll('button.active').forEach(btn => btn.classList.remove('active'));
            const currentBtn = document.getElementById(mode + '-mode') || document.getElementById(mode + '-btn');
            if (currentBtn) currentBtn.classList.add('active');

            canvas.selection = mode === 'select';
            canvas.forEachObject(obj => { if (obj.stroke !== '#e0e0e0') obj.selectable = (mode === 'select'); });
            canvas.renderAll();
        }

        // 키보드/마우스 이벤트 핸들러
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT') return;
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); history.undo(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); history.redo(); }
            if (e.key === 'Backspace') { e.preventDefault(); deleteSelectedObjects(); }
            if (e.key.toLowerCase() === 'v') setMode('select');
        });

        // 줌, 팬, 그리기 이벤트
        canvas.on('mouse:wheel', (opt) => {
            if (opt.e.ctrlKey) {
                const delta = opt.e.deltaY;
                let zoom = canvas.getZoom();
                zoom *= 0.999 ** delta;
                if (zoom > 20) zoom = 20;
                if (zoom < 0.1) zoom = 0.1;
                canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
                opt.e.preventDefault();
                opt.e.stopPropagation();
            }
        });

        canvas.on('mouse:down', (e) => {
            if (e.e.button === 1) { // 휠(가운데) 버튼 클릭
                isPanning = true;
                lastPosX = e.e.clientX;
                lastPosY = e.e.clientY;
                canvas.setCursor('grabbing');
                canvas.selection = false;
                return;
            }
            
            if (currentMode === 'select' || isDrawing) return;
            
            const pointer = canvas.getPointer(e.e);
            startX = pointer.x;
            startY = pointer.y;
            isDrawing = true;

            // ======[업데이트된 코드 2]======
            // 객체 삽입 후 자동으로 '선택' 모드로 전환
            let insertedObject = null;
            switch(currentMode) {
                case 'wall':
                    currentLine = new fabric.Line([startX, startY, startX, startY], { stroke: 'black', strokeWidth: 6, strokeLineCap: 'square', selectable: false });
                    canvas.add(currentLine);
                    break;
                case 'text':
                    const text = prompt('텍스트를 입력하세요:');
                    if (text) {
                        insertedObject = new fabric.Text(text, { left: startX, top: startY, fontSize: 14, fill: 'black' });
                        canvas.add(insertedObject);
                    }
                    isDrawing = false;
                    break;
                case 'door': insertedObject = createDoor(startX, startY); canvas.add(insertedObject); isDrawing = false; break;
                case 'window': insertedObject = createWindow(startX, startY); canvas.add(insertedObject); isDrawing = false; break;
                case 'slidingDoor': insertedObject = createSlidingDoor(startX, startY); canvas.add(insertedObject); isDrawing = false; break;
                case 'stairs': insertedObject = createStairs(startX, startY); canvas.add(insertedObject); isDrawing = false; break;
            }

            if (insertedObject) {
                setMode('select');
                canvas.setActiveObject(insertedObject);
            }
            // ============================
        });

        canvas.on('mouse:move', (e) => {
            if (isPanning) {
                const vpt = canvas.viewportTransform;
                vpt[4] += e.e.clientX - lastPosX;
                vpt[5] += e.e.clientY - lastPosY;
                canvas.requestRenderAll();
                lastPosX = e.e.clientX;
                lastPosY = e.e.clientY;
                return;
            }
            if (!isDrawing || !currentLine) return;
            
            const pointer = canvas.getPointer(e.e);
            let endX = pointer.x, endY = pointer.y;
            if (e.e.shiftKey) {
                const dx = Math.abs(pointer.x - startX);
                const dy = Math.abs(pointer.y - startY);
                if (dx > dy) { endY = startY; } else { endX = startX; }
            }
            currentLine.set({ x2: endX, y2: endY });
            canvas.renderAll();
        });

        canvas.on('mouse:up', (e) => {
            if (isPanning) {
                isPanning = false;
                canvas.setCursor('default');
                canvas.selection = (currentMode === 'select');
                return;
            }
            if (!isDrawing) return;

            if (currentMode === 'wall' && currentLine) {
                currentLine.setCoords();
                history.saveState();
            } else if (currentMode === 'rect') {
                const pointer = canvas.getPointer(e.e);
                const width = Math.abs(pointer.x - startX);
                const height = Math.abs(pointer.y - startY);
                if (width > 2 && height > 2) {
                    const rect = new fabric.Rect({
                        left: Math.min(startX, pointer.x),
                        top: Math.min(startY, pointer.y),
                        width: width, height: height,
                        fill: 'transparent', stroke: 'black', strokeWidth: 2
                    });
                    canvas.add(rect);
                }
            }
            
            isDrawing = false;
            currentLine = null;
        });

        // 객체 선택 및 크기 조절 관련 이벤트
        canvas.on({
            'selection:created': (e) => updateSelection(e.selected),
            'selection:updated': (e) => updateSelection(e.selected),
            'selection:cleared': () => updateSelection([]),
            'object:scaling': updateSizeControls,
            'object:rotating': updateSizeControls,
        });

        function updateSelection(selected) {
            selectedObject = selected.length === 1 ? selected[0] : null;
            if (selectedObject) {
                sizeControls.classList.add('show');
                updateSizeControls();
            } else {
                sizeControls.classList.remove('show');
            }
        }

        function updateSizeControls() {
            if (selectedObject) {
                widthInput.value = Math.round(selectedObject.getScaledWidth());
                heightInput.value = Math.round(selectedObject.getScaledHeight());
                angleInput.value = Math.round(selectedObject.angle);
            }
        }
        
        widthInput.addEventListener('input', () => { if (selectedObject) { selectedObject.scaleToWidth(parseInt(widthInput.value)); canvas.renderAll(); }});
        heightInput.addEventListener('input', () => { if (selectedObject) { selectedObject.scaleToHeight(parseInt(heightInput.value)); canvas.renderAll(); }});
        angleInput.addEventListener('input', () => { if (selectedObject) { selectedObject.set('angle', parseInt(angleInput.value)).setCoords(); canvas.renderAll(); }});
        
        // 버튼 클릭 이벤트 리스너
        selectBtn.addEventListener('click', () => setMode('select'));
        wallBtn.addEventListener('click', () => setMode('wall'));
        rectBtn.addEventListener('click', () => setMode('rect'));
        textBtn.addEventListener('click', () => setMode('text'));
        doorBtn.addEventListener('click', () => setMode('door'));
        windowBtn.addEventListener('click', () => setMode('window'));
        slidingDoorBtn.addEventListener('click', () => setMode('slidingDoor'));
        stairsBtn.addEventListener('click', () => setMode('stairs'));
        undoBtn.addEventListener('click', () => history.undo());
        redoBtn.addEventListener('click', () => history.redo());
        deleteBtn.addEventListener('click', deleteSelectedObjects);

        function deleteSelectedObjects() {
            canvas.getActiveObjects().forEach(obj => canvas.remove(obj));
            canvas.discardActiveObject().renderAll();
        }
        
        // 파일/전체삭제/그리드 기능 (나머지 코드는 이전과 동일)
        document.getElementById('clear-btn').addEventListener('click', () => {
            if (confirm('모든 내용을 삭제하시겠습니까?\n(배경 이미지도 함께 제거됩니다)')) {
                history.isRestoring = true;
                canvas.clear();
                canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
                canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas));
                canvas.backgroundColor = 'white';
                backgroundImage = null;
                bgClearBtn.disabled = true;
                opacityControl.style.display = 'none';
                if (showGrid) drawGrid();
                history.isRestoring = false;
                history.saveState();
            }
        });
        
        bgImageBtn.addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    fabric.Image.fromURL(event.target.result, (img) => {
                        const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
                        img.set({ scaleX: scale, scaleY: scale, opacity: bgOpacity.value / 100 });
                        canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), { originX: 'left', originY: 'top' });
                        backgroundImage = img;
                        bgClearBtn.disabled = false;
                        opacityControl.style.display = 'block';
                    });
                };
                reader.readAsDataURL(e.target.files[0]);
            };
            input.click();
        });

        bgClearBtn.addEventListener('click', () => {
            canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas));
            backgroundImage = null;
            bgClearBtn.disabled = true;
            opacityControl.style.display = 'none';
        });

        bgOpacity.addEventListener('input', (e) => {
            const opacity = e.target.value;
            opacityValue.textContent = opacity + '%';
            if (backgroundImage) {
                backgroundImage.set('opacity', opacity / 100);
                canvas.renderAll();
            }
        });
        
        function drawGrid() { /* ... */ } // 그리드 로직은 생략. 이전과 동일
        canvas.on('after:render', () => { if (showGrid) drawGrid(); });
        gridBtn.addEventListener('click', () => {
            showGrid = !showGrid;
            gridBtn.classList.toggle('active', showGrid);
            canvas.getObjects().forEach(o => { if(o.stroke === '#e0e0e0') canvas.remove(o) });
            if (showGrid) drawGrid();
            canvas.renderAll();
        });
        
        document.getElementById('export-btn').addEventListener('click', () => { /* ... */ }); // 이전과 동일
        document.getElementById('save-btn').addEventListener('click', () => { /* ... */ }); // 이전과 동일
        document.getElementById('load-btn').addEventListener('click', () => { /* ... */ }); // 이전과 동일
        
        // 초기화
        setMode('select');
    </script>
</body>
</html>
