<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAD 스타일 평면도 편집기</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Malgun Gothic', sans-serif;
            background-color: #f0f0f0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tool-group {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        
        .tool-group h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }
        
        button {
            padding: 8px 15px;
            border: 1px solid #ddd;
            background-color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 2px;
            position: relative;
        }
        
        button:hover {
            background-color: #e0e0e0;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button.active {
            background-color: #4CAF50;
            color: white;
        }
        
        .icon-btn {
            width: 50px;
            height: 50px;
            padding: 5px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        
        .icon-btn svg {
            width: 30px;
            height: 30px;
        }
        
        .icon-btn span {
            font-size: 10px;
            margin-top: 2px;
        }
        
        #canvas-container {
            border: 2px solid #ddd;
            border-radius: 4px;
            background-color: white;
            position: relative;
            overflow: hidden; 
            width: 100%;
            height: 700px; 
        }
        
        .size-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            display: none;
            z-index: 10;
        }
        
        .size-controls.show {
            display: block;
        }
        
        .size-controls label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        .size-controls input {
            width: 60px;
            margin-left: 5px;
        }
        
        .info {
            margin-top: 20px;
            padding: 15px;
            background-color: #e8f4f8;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .shortcut {
            color: #666;
            font-size: 11px;
            margin-left: 5px;
        }
        
        .history-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 12px;
            color: #666;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CAD 스타일 평면도 편집기</h1>

        <div class="toolbar">
            <div class="tool-group">
                <h3>기본 도구</h3>
                <button id="select-mode" class="active">선택<span class="shortcut">V</span></button>
                <button id="wall-mode">벽</button>
                <button id="rect-mode">사각형</button>
                <button id="text-mode">텍스트</button>
                <button id="delete-btn">삭제<span class="shortcut">Backspace</span></button>
            </div>
            
            <div class="tool-group">
                <h3>편집</h3>
                <button id="undo-btn" disabled>실행취소<span class="shortcut">Ctrl+Z</span></button>
                <button id="redo-btn" disabled>다시실행<span class="shortcut">Ctrl+Y</span></button>
            </div>
            
            <div class="tool-group">
                <h3>건축 요소</h3>
                <button id="door-btn" class="icon-btn" title="문 (클릭 또는 드래그)" draggable="true">
                    <svg viewBox="0 0 60 60"><line x1="10" y1="50" x2="50" y2="50" stroke="black" stroke-width="3"/><path d="M 10 50 Q 30 30, 50 50" stroke="black" stroke-width="2" fill="none"/></svg>
                </button>
                <button id="window-btn" class="icon-btn" title="창문 (클릭 또는 드래그)" draggable="true">
                    <svg viewBox="0 0 60 60"><rect x="10" y="25" width="40" height="10" fill="none" stroke="black" stroke-width="2"/><line x1="10" y1="30" x2="50" y2="30" stroke="black" stroke-width="1"/></svg>
                </button>
                <button id="sliding-door-btn" class="icon-btn" title="미닫이문 (클릭 또는 드래그)" draggable="true">
                    <svg viewBox="0 0 60 60"><line x1="10" y1="30" x2="50" y2="30" stroke="black" stroke-width="3"/><rect x="15" y="25" width="15" height="10" fill="none" stroke="black" stroke-width="2"/><rect x="30" y="25" width="15" height="10" fill="none" stroke="black" stroke-width="2"/></svg>
                </button>
                <button id="stairs-btn" class="icon-btn" title="계단 (클릭 또는 드래그)" draggable="true">
                    <svg viewBox="0 0 60 60"><g><line x1="10" y1="15" x2="50" y2="15" stroke="black" stroke-width="1"/><line x1="10" y1="25" x2="50" y2="25" stroke="black" stroke-width="1"/><line x1="10" y1="35" x2="50" y2="35" stroke="black" stroke-width="1"/><line x1="10" y1="45" x2="50" y2="45" stroke="black" stroke-width="1"/><polygon points="25,10 30,20 20,20" fill="black"/></g></svg>
                </button>
            </div>
            
            <div class="tool-group">
                <h3>파일</h3>
                <button id="save-btn">저장</button>
                <button id="load-btn">불러오기</button>
                <button id="export-btn">이미지 내보내기</button>
                <button id="clear-btn">전체 삭제</button>
            </div>
            
            <div class="tool-group">
                <h3>배경 이미지</h3>
                <button id="bg-image-btn">이미지 불러오기</button>
                <button id="bg-clear-btn" disabled>이미지 제거</button>
                <div style="margin-top: 10px; display: none;" id="opacity-control">
                    <label style="font-size: 12px;">불투명도: 
                        <input type="range" id="bg-opacity" min="10" max="100" value="50" style="width: 100px; vertical-align: middle;">
                        <span id="opacity-value">50%</span>
                    </label>
                </div>
            </div>
            
            <div class="tool-group">
                <h3>보기</h3>
                <button id="grid-btn">격자 표시</button>
            </div>
        </div>
        
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
            <div class="size-controls" id="size-controls">
                <label>너비: <input type="number" id="width-input" min="10" step="5"></label>
                <label>높이: <input type="number" id="height-input" min="10" step="5"></label>
                <label>각도: <input type="number" id="angle-input" min="0" max="360" step="15"></label>
            </div>
            <div class="history-counter" id="history-counter"></div>
        </div>
        
        <div class="info">
            <strong>사용법:</strong>
            <ul>
                <li>건축 요소 삽입: 아이콘을 클릭 후 캔버스에 클릭하거나, 아이콘을 캔버스로 드래그 앤 드롭합니다. <strong>(드롭 시 화면 중앙에 배치)</strong></li>
                <li>배경 이미지: 거래처 도면을 불러와서 위에 따라 그릴 수 있습니다.</li>
                <li>확대/축소: Ctrl 키를 누른 채 마우스 휠을 돌려 조절합니다.</li>
                <li>화면 이동: 마우스 휠(가운데 버튼)을 클릭한 상태로 드래그합니다.</li>
                <li>선택 모드: V 키 또는 버튼 클릭. 객체를 클릭/드래그하여 선택, 이동, 회전이 가능합니다.</li>
                <li>크기 조절: 객체 모서리를 드래그하여 조절합니다. Shift 키를 누른 채 드래그하면 정비율로 조절됩니다.</li>
                <li>벽/사각형 그리기: 클릭하고 드래그하여 그립니다. (그리기 완료 후 자동으로 선택 모드 전환)</li>
                <li>객체 삭제: 객체 선택 후 Backspace 키 또는 삭제 버튼 클릭.</li>
                <li>실행취소/다시실행: Ctrl+Z / Ctrl+Y 또는 버튼 클릭.</li>
            </ul>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script>
        const canvasContainer = document.getElementById('canvas-container');
        const canvasEl = document.getElementById('canvas');
        canvasEl.width = canvasContainer.clientWidth;
        canvasEl.height = canvasContainer.clientHeight;

        const canvas = new fabric.Canvas('canvas', {
            backgroundColor: 'white',
            selection: true,
            stopContextMenu: true, 
            fireRightClick: true,
            uniScaleTransform: true, 
        });

        const history = {
            states: [], currentIndex: -1, maxSize: 50, isRestoring: false,
            saveState() { if (this.isRestoring) return; this.states = this.states.slice(0, this.currentIndex + 1); const state = JSON.stringify(canvas.toJSON(['elementType'])); this.states.push(state); if (this.states.length > this.maxSize) { this.states.shift(); } else { this.currentIndex++; } this.updateButtons(); this.updateCounter(); },
            undo() { if (this.currentIndex > 0) { this.currentIndex--; this.restore(this.states[this.currentIndex]); } },
            redo() { if (this.currentIndex < this.states.length - 1) { this.currentIndex++; this.restore(this.states[this.currentIndex]); } },
            restore(state) { this.isRestoring = true; const vpt = canvas.viewportTransform; canvas.loadFromJSON(state, () => { canvas.viewportTransform = vpt; canvas.renderAll(); if (showGrid) drawGrid(); this.isRestoring = false; this.updateButtons(); this.updateCounter(); }); },
            updateButtons() { undoBtn.disabled = this.currentIndex <= 0; redoBtn.disabled = this.currentIndex >= this.states.length - 1; },
            updateCounter() { const counter = document.getElementById('history-counter'); counter.textContent = `${this.currentIndex + 1} / ${this.states.length}`; }
        };

        const gridSize = 20;
        let showGrid = false, currentMode = 'select', isDrawing = false;
        let startX, startY, currentLine = null, selectedObject = null;
        let isPanning = false, lastPosX, lastPosY;
        let backgroundImage = null;
        
        const bgImageBtn = document.getElementById('bg-image-btn'), bgClearBtn = document.getElementById('bg-clear-btn'), bgOpacity = document.getElementById('bg-opacity'), opacityValue = document.getElementById('opacity-value'), opacityControl = document.getElementById('opacity-control');
        const selectBtn = document.getElementById('select-mode'), wallBtn = document.getElementById('wall-mode'), rectBtn = document.getElementById('rect-mode'), textBtn = document.getElementById('text-mode'), deleteBtn = document.getElementById('delete-btn');
        const doorBtn = document.getElementById('door-btn'), windowBtn = document.getElementById('window-btn'), slidingDoorBtn = document.getElementById('sliding-door-btn'), stairsBtn = document.getElementById('stairs-btn');
        const gridBtn = document.getElementById('grid-btn'), undoBtn = document.getElementById('undo-btn'), redoBtn = document.getElementById('redo-btn');
        const sizeControls = document.getElementById('size-controls'), widthInput = document.getElementById('width-input'), heightInput = document.getElementById('height-input'), angleInput = document.getElementById('angle-input');

        history.saveState();

        canvas.on({ 'object:added': () => { if (!history.isRestoring) history.saveState(); }, 'object:modified': () => history.saveState(), 'object:removed': () => { if (!history.isRestoring) history.saveState(); } });

        function createDoor(x, y) { const g = new fabric.Group([], { left: x, top: y, originX: 'center', originY: 'center' }); g.addWithUpdate(new fabric.Rect({ left: -40, top: -3, width: 80, height: 6, fill: 'white', stroke: 'black', strokeWidth: 2 })); g.addWithUpdate(new fabric.Path('M -40 0 Q -40 -40, 0 -40', { fill: '', stroke: 'black', strokeWidth: 2 })); g.elementType = 'door'; return g; }
        function createWindow(x, y) { const g = new fabric.Group([], { left: x, top: y, originX: 'center', originY: 'center' }); g.addWithUpdate(new fabric.Rect({ left: -30, top: -4, width: 60, height: 8, fill: 'white', stroke: 'black', strokeWidth: 2 })); g.addWithUpdate(new fabric.Line([-30, 0, 30, 0], { stroke: 'black', strokeWidth: 1 })); g.elementType = 'window'; return g; }
        function createSlidingDoor(x, y) { const g = new fabric.Group([], { left: x, top: y, originX: 'center', originY: 'center' }); g.addWithUpdate(new fabric.Line([-40, 0, 40, 0], { stroke: 'black', strokeWidth: 3 })); g.addWithUpdate(new fabric.Rect({ left: -35, top: -5, width: 30, height: 10, fill: 'transparent', stroke: 'black', strokeWidth: 2 })); g.addWithUpdate(new fabric.Rect({ left: -5, top: -5, width: 30, height: 10, fill: 'transparent', stroke: 'black', strokeWidth: 2 })); g.elementType = 'slidingDoor'; return g; }
        function createStairs(x, y) { const g = new fabric.Group([], { left: x, top: y, originX: 'center', originY: 'center' }); for (let i = 0; i < 6; i++) { g.addWithUpdate(new fabric.Line([-30, -25 + i * 10, 30, -25 + i * 10], { stroke: 'black', strokeWidth: 1 })); } g.addWithUpdate(new fabric.Polygon([{x: 0, y: -35}, {x: -5, y: -25}, {x: 5, y: -25}], { fill: 'black' })); g.elementType = 'stairs'; return g; }
        
        function setMode(mode) { currentMode = mode; document.querySelectorAll('button.active').forEach(btn => btn.classList.remove('active')); const currentBtn = document.getElementById(mode + '-mode') || document.getElementById(mode + '-btn'); if (currentBtn) currentBtn.classList.add('active'); canvas.selection = mode === 'select'; canvas.forEachObject(obj => { if (obj.stroke !== '#e0e0e0') obj.selectable = (mode === 'select'); }); canvas.renderAll(); }

        document.addEventListener('keydown', (e) => { if (e.target.tagName === 'INPUT') return; if ((e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'Z')) { e.preventDefault(); history.undo(); } if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || e.key === 'Y')) { e.preventDefault(); history.redo(); } if (e.key === 'Backspace') { e.preventDefault(); deleteSelectedObjects(); } if (e.key.toLowerCase() === 'v') setMode('select'); });

        canvas.on('mouse:wheel', (opt) => { if (opt.e.ctrlKey) { const delta = opt.e.deltaY; let zoom = canvas.getZoom(); zoom *= 0.999 ** delta; if (zoom > 20) zoom = 20; if (zoom < 0.1) zoom = 0.1; canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom); opt.e.preventDefault(); opt.e.stopPropagation(); } });

        canvas.on('mouse:down', (e) => {
            if (e.e.button === 1) { isPanning = true; lastPosX = e.e.clientX; lastPosY = e.e.clientY; canvas.setCursor('grabbing'); canvas.selection = false; return; }
            if (currentMode === 'select' || isDrawing) return;
            const pointer = canvas.getPointer(e.e); startX = pointer.x; startY = pointer.y; isDrawing = true;
            let insertedObject = null;
            switch(currentMode) {
                case 'wall': currentLine = new fabric.Line([startX, startY, startX, startY], { stroke: 'black', strokeWidth: 6, strokeLineCap: 'square', selectable: false }); canvas.add(currentLine); break;
                case 'text': const text = prompt('텍스트를 입력하세요:'); if (text) { insertedObject = new fabric.Text(text, { left: startX, top: startY, fontSize: 14, fill: 'black' }); canvas.add(insertedObject); } isDrawing = false; break;
                case 'door': insertedObject = createDoor(startX, startY); canvas.add(insertedObject); isDrawing = false; break;
                case 'window': insertedObject = createWindow(startX, startY); canvas.add(insertedObject); isDrawing = false; break;
                case 'slidingDoor': insertedObject = createSlidingDoor(startX, startY); canvas.add(insertedObject); isDrawing = false; break;
                case 'stairs': insertedObject = createStairs(startX, startY); canvas.add(insertedObject); isDrawing = false; break;
            }
            if (insertedObject) { setMode('select'); canvas.setActiveObject(insertedObject); }
        });

        canvas.on('mouse:move', (e) => {
            if (isPanning) { const vpt = canvas.viewportTransform; vpt[4] += e.e.clientX - lastPosX; vpt[5] += e.e.clientY - lastPosY; canvas.requestRenderAll(); lastPosX = e.e.clientX; lastPosY = e.e.clientY; return; }
            if (!isDrawing) return;
            if (currentMode === 'wall' && currentLine) { const pointer = canvas.getPointer(e.e); let endX = pointer.x, endY = pointer.y; if (e.e.shiftKey) { const dx = Math.abs(pointer.x - startX); const dy = Math.abs(pointer.y - startY); if (dx > dy) { endY = startY; } else { endX = startX; } } currentLine.set({ x2: endX, y2: endY }); canvas.renderAll(); }
            else if (currentMode === 'rect' && isDrawing) { const pointer = canvas.getPointer(e.e); const width = Math.abs(pointer.x - startX); const height = Math.abs(pointer.y - startY); if(!currentLine) { currentLine = new fabric.Rect({ left: startX, top: startY, width: 0, height: 0, fill: 'transparent', stroke: 'black', strokeWidth: 2, strokeDashArray: [5, 5] }); canvas.add(currentLine); } currentLine.set({ left: Math.min(pointer.x, startX), top: Math.min(pointer.y, startY), width: width, height: height }); canvas.renderAll(); }
        });
        
        canvas.on('mouse:up', (e) => {
            if (isPanning) { isPanning = false; canvas.setCursor('default'); canvas.selection = (currentMode === 'select'); return; }
            if (!isDrawing) return;
            let newObject = null;
            if (currentMode === 'wall' && currentLine) { currentLine.set({selectable: true}).setCoords(); newObject = currentLine; } 
            else if (currentMode === 'rect' && currentLine) { canvas.remove(currentLine); const pointer = canvas.getPointer(e.e); const width = Math.abs(pointer.x - startX); const height = Math.abs(pointer.y - startY); if (width > 2 && height > 2) { newObject = new fabric.Rect({ left: Math.min(startX, pointer.x), top: Math.min(startY, pointer.y), width, height, fill: 'transparent', stroke: 'black', strokeWidth: 2 }); canvas.add(newObject); } }
            if(newObject) { setMode('select'); canvas.setActiveObject(newObject); }
            isDrawing = false; currentLine = null;
        });

        canvas.on({ 'selection:created': (e) => updateSelection(e.selected), 'selection:updated': (e) => updateSelection(e.selected), 'selection:cleared': () => updateSelection([]), 'object:scaling': updateSizeControls, 'object:rotating': updateSizeControls });
        function updateSelection(selected) { selectedObject = selected.length === 1 ? selected[0] : null; if (selectedObject) { sizeControls.classList.add('show'); updateSizeControls(); } else { sizeControls.classList.remove('show'); } }
        function updateSizeControls() { if (selectedObject) { widthInput.value = Math.round(selectedObject.getScaledWidth()); heightInput.value = Math.round(selectedObject.getScaledHeight()); angleInput.value = Math.round(selectedObject.angle); } }
        widthInput.addEventListener('input', () => { if (selectedObject) { selectedObject.scaleToWidth(parseInt(widthInput.value, 10)); canvas.renderAll(); }});
        heightInput.addEventListener('input', () => { if (selectedObject) { selectedObject.scaleToHeight(parseInt(heightInput.value, 10)); canvas.renderAll(); }});
        angleInput.addEventListener('input', () => { if (selectedObject) { selectedObject.set('angle', parseInt(angleInput.value, 10)).setCoords(); canvas.renderAll(); }});
        
        selectBtn.addEventListener('click', () => setMode('select')); wallBtn.addEventListener('click', () => setMode('wall')); rectBtn.addEventListener('click', () => setMode('rect')); textBtn.addEventListener('click', () => setMode('text'));
        doorBtn.addEventListener('click', () => setMode('door')); windowBtn.addEventListener('click', () => setMode('window')); slidingDoorBtn.addEventListener('click', () => setMode('slidingDoor')); stairsBtn.addEventListener('click', () => setMode('stairs'));
        undoBtn.addEventListener('click', () => history.undo()); redoBtn.addEventListener('click', () => history.redo()); deleteBtn.addEventListener('click', deleteSelectedObjects);
        function deleteSelectedObjects() { canvas.getActiveObjects().forEach(obj => canvas.remove(obj)); canvas.discardActiveObject().renderAll(); }
        
        // 드래그 앤 드롭 기능
        const draggableElements = ['door-btn', 'window-btn', 'sliding-door-btn', 'stairs-btn'];
        draggableElements.forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('dragstart', (e) => {
                e.dataTransfer.setData('text/plain', id.replace('-btn', ''));
            });
        });

        canvasContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        // ======[업데이트된 코드]======
        canvasContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            const type = e.dataTransfer.getData('text/plain');

            // 현재 보이는 화면(뷰포트)의 중앙 좌표 계산
            const zoom = canvas.getZoom();
            const panX = canvas.viewportTransform[4];
            const panY = canvas.viewportTransform[5];
            
            // 캔버스 요소의 중앙
            const viewCenterX = canvas.width / 2;
            const viewCenterY = canvas.height / 2;
            
            // 뷰포트 중앙 좌표를 캔버스의 절대 좌표로 변환
            const centerX = (viewCenterX - panX) / zoom;
            const centerY = (viewCenterY - panY) / zoom;

            let newObject = null;
            switch(type) {
                case 'door': newObject = createDoor(centerX, centerY); break;
                case 'window': newObject = createWindow(centerX, centerY); break;
                case 'sliding-door': newObject = createSlidingDoor(centerX, centerY); break; // id가 다르므로 'sliding-door'로 수정
                case 'stairs': newObject = createStairs(centerX, centerY); break;
            }
            if (newObject) {
                canvas.add(newObject);
                setMode('select');
                canvas.setActiveObject(newObject);
                canvas.renderAll();
            }
        });
        // ============================
        
        document.getElementById('clear-btn').addEventListener('click', () => { if (confirm('모든 내용을 삭제하시겠습니까?\n(배경 이미지도 함께 제거됩니다)')) { history.isRestoring = true; canvas.clear(); canvas.setViewportTransform([1, 0, 0, 1, 0, 0]); canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas)); canvas.backgroundColor = 'white'; backgroundImage = null; bgClearBtn.disabled = true; opacityControl.style.display = 'none'; if (showGrid) drawGrid(); history.isRestoring = false; history.saveState(); } });
        bgImageBtn.addEventListener('click', () => { const input = document.createElement('input'); input.type = 'file'; input.accept = 'image/*'; input.onchange = (e) => { const reader = new FileReader(); reader.onload = (event) => { fabric.Image.fromURL(event.target.result, (img) => { const scale = Math.min(canvas.width / img.width, canvas.height / img.height); img.set({ scaleX: scale, scaleY: scale, opacity: bgOpacity.value / 100 }); canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), { originX: 'left', originY: 'top' }); backgroundImage = img; bgClearBtn.disabled = false; opacityControl.style.display = 'block'; }); }; reader.readAsDataURL(e.target.files[0]); }; input.click(); });
        bgClearBtn.addEventListener('click', () => { canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas)); backgroundImage = null; bgClearBtn.disabled = true; opacityControl.style.display = 'none'; });
        bgOpacity.addEventListener('input', (e) => { const opacity = e.target.value; opacityValue.textContent = opacity + '%'; if (backgroundImage) { backgroundImage.set('opacity', opacity / 100); canvas.renderAll(); } });
        
        function drawGrid() { canvas.getObjects().forEach(o => { if (o.isGridLine) canvas.remove(o) }); const zoom = canvas.getZoom(); const panX = canvas.viewportTransform[4]; const panY = canvas.viewportTransform[5]; for (let i = Math.floor(-panX / (gridSize * zoom)); i * gridSize < canvas.width / zoom; i++) { const x = i * gridSize; const line = new fabric.Line([x, -panY / zoom, x, (canvas.height - panY) / zoom], { stroke: '#e0e0e0', strokeWidth: 1, selectable: false, evented: false, isGridLine: true }); canvas.add(line); } for (let i = Math.floor(-panY / (gridSize * zoom)); i * gridSize < canvas.height / zoom; i++) { const y = i * gridSize; const line = new fabric.Line([-panX / zoom, y, (canvas.width - panX) / zoom, y], { stroke: '#e0e0e0', strokeWidth: 1, selectable: false, evented: false, isGridLine: true }); canvas.add(line); } canvas.getObjects().filter(o => o.isGridLine).forEach(o => canvas.sendToBack(o)); }
        canvas.on('after:render', () => { if (showGrid) drawGrid(); });
        gridBtn.addEventListener('click', () => { showGrid = !showGrid; gridBtn.classList.toggle('active', showGrid); if (!showGrid) { canvas.getObjects().forEach(o => { if(o.isGridLine) canvas.remove(o) }); } canvas.renderAll(); });
        
        document.getElementById('export-btn').addEventListener('click', () => { const link = document.createElement('a'); link.download = '평면도.png'; link.href = canvas.toDataURL({format: 'png', quality: 1}); link.click(); });
        document.getElementById('save-btn').addEventListener('click', () => { const data = { version: '2.0', canvas: canvas.toJSON(['elementType']), viewport: canvas.viewportTransform, backgroundImage: backgroundImage ? { src: canvas.backgroundImage._element.src, opacity: backgroundImage.opacity, scaleX: backgroundImage.scaleX, scaleY: backgroundImage.scaleY } : null }; const blob = new Blob([JSON.stringify(data)], { type: 'application/json' }); const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.download = '평면도.json'; link.href = url; link.click(); URL.revokeObjectURL(url); });
        document.getElementById('load-btn').addEventListener('click', () => { const input = document.createElement('input'); input.type = 'file'; input.accept = '.json'; input.onchange = (e) => { const reader = new FileReader(); reader.onload = (event) => { const data = JSON.parse(event.target.result); history.isRestoring = true; canvas.loadFromJSON(data.canvas || data, () => { if (data.viewport) canvas.setViewportTransform(data.viewport); if (data.backgroundImage) { fabric.Image.fromURL(data.backgroundImage.src, (img) => { img.set(data.backgroundImage); canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas)); backgroundImage = img; bgClearBtn.disabled = false; opacityControl.style.display = 'block'; bgOpacity.value = (data.backgroundImage.opacity || 1) * 100; opacityValue.textContent = `${Math.round(bgOpacity.value)}%`; }); } canvas.renderAll(); history.isRestoring = false; history.saveState(); }); }; reader.readAsText(e.target.files[0]); }; input.click(); });
        
        setMode('select');
    </script>
</body>
</html>
