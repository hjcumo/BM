<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HB 평면도 간이 편집기 by.MK</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            font-family: 'Malgun Gothic', sans-serif;
            background-color: #f0f0f0;
            overflow: hidden; /* 전체 페이지 스크롤 방지 */
        }

        .container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: white;
            box-sizing: border-box;
            padding: 10px;
        }
        
        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            flex-shrink: 0; /* 툴바 높이 고정 */
        }
        
        .tool-group {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        
        .tool-group h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }
        
        button {
            padding: 8px 15px;
            border: 1px solid #ddd;
            background-color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 2px;
            position: relative;
        }
        
        button:hover {
            background-color: #e0e0e0;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button.active {
            background-color: #4CAF50;
            color: white;
        }
        
        .icon-btn {
            width: 50px;
            height: 50px;
            padding: 5px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        
        .icon-btn svg {
            width: 100%;
            height: 100%;
        }
        
        .icon-btn span {
            font-size: 10px;
            margin-top: 2px;
        }

        .main-content {
            display: flex;
            gap: 10px;
            flex-grow: 1; /* 남은 세로 공간을 모두 차지 */
            overflow: hidden; /* 내부 요소가 넘치지 않도록 */
        }

        #canvas-container {
            flex-grow: 1; /* 남은 가로 공간을 모두 차지 */
            border: 2px solid #ddd;
            border-radius: 4px;
            background-color: white;
            position: relative;
            overflow: hidden; 
        }

        #object-panel {
            width: 240px;
            flex-shrink: 0; /* 너비 고정 */
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
        }

        #object-panel-header {
            padding: 10px;
            font-weight: bold;
            border-bottom: 1px solid #ddd;
            background-color: #f0f0f0;
        }

        #object-panel-list {
            list-style: none;
            margin: 0;
            padding: 0;
            overflow-y: auto;
            flex-grow: 1;
        }

        #object-panel-list li {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #object-panel-list li:hover {
            background-color: #e0e0e0;
        }
        
        #object-panel-list li.selected {
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
        }
        
        .size-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            display: none;
            z-index: 10;
        }
        
        .size-controls.show { display: block; }
        
        .size-controls label { display: block; margin-bottom: 5px; font-size: 12px; }
        .size-controls input { width: 60px; margin-left: 5px; }
        
        .stroke-control {
            margin-top: 10px;
            padding: 5px;
            background-color: #f5f5f5;
            border-radius: 3px;
        }
        
        .stroke-control label {
            font-size: 12px;
            font-weight: bold;
        }
        
        .stroke-control input[type="number"] {
            width: 50px;
            margin: 0 5px;
        }
        
        /* 스냅 컨트롤 스타일 */
        .snap-control {
            margin-top: 10px;
            padding: 8px;
            background-color: #e8f4f8;
            border-radius: 3px;
            border: 1px solid #b3d9e8;
        }
        
        .snap-control label {
            font-size: 12px;
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        }
        
        .snap-control input[type="number"] {
            width: 60px;
            margin: 0 5px;
            padding: 3px;
        }
        
        .snap-control .unit {
            font-size: 11px;
            color: #666;
        }
        
        .snap-control .info-text {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
        }
        
        .info { 
            margin-top: 10px; 
            padding: 0 15px 15px 15px; 
            background-color: #e8f4f8; 
            border-radius: 4px; 
            font-size: 14px; 
            flex-shrink: 0;
            overflow: hidden;
            transition: all 0.3s ease-out;
        }
        .info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 12px 0;
        }
        .toggle-icon {
            font-size: 12px;
            transition: transform 0.3s;
        }
        .info.collapsed {
            padding-top: 0;
            padding-bottom: 0;
        }
        .info.collapsed > ul {
            display: none;
        }
        .info.collapsed .toggle-icon {
             transform: rotate(-90deg);
        }

        .shortcut { color: #666; font-size: 11px; margin-left: 5px; }
        
        .history-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 12px;
            color: #666;
            z-index: 10;
        }

        /* 컨텍스트 메뉴 스타일 */
        #context-menu {
            position: absolute;
            display: none;
            background-color: white;
            border: 1px solid #ddd;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border-radius: 4px;
            z-index: 1000;
            padding: 5px 0;
        }
        #context-menu button {
            display: block;
            width: 100%;
            padding: 8px 20px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
        }
        #context-menu button:hover {
            background-color: #f0f0f0;
        }
        
        /* 스냅 포인트 하이라이트 스타일 */
        .snap-indicator {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid #ff0000;
            border-radius: 50%;
            background-color: rgba(255, 0, 0, 0.3);
            pointer-events: none;
            z-index: 1000;
            transform: translate(-50%, -50%);
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="toolbar">
            <div class="tool-group">
                <h3>기본 도구</h3>
                <button id="select-mode" class="active">선택<span class="shortcut">V</span></button>
                <button id="wall-mode">벽<span class="shortcut">W</span></button>
                <button id="rect-mode">사각형<span class="shortcut">R</span></button>
                <button id="text-mode">텍스트</button>
                <button id="delete-btn">삭제<span class="shortcut">Backspace</span></button>
            </div>
            
            <div class="tool-group">
                <h3>편집</h3>
                <button id="copy-btn" disabled>복사<span class="shortcut">Ctrl+C</span></button>
                <button id="paste-btn" disabled>붙여넣기<span class="shortcut">Ctrl+V</span></button>
                <button id="undo-btn" disabled>실행취소<span class="shortcut">Ctrl+Z</span></button>
                <button id="redo-btn" disabled>다시실행<span class="shortcut">Ctrl+Y</span></button>
            </div>
            
            <div class="tool-group">
                <h3>선 스타일</h3>
                <div class="stroke-control">
                    <label>선 두께: 
                        <input type="number" id="default-stroke-width" min="1" max="20" value="2" step="1">px
                    </label>
                </div>
            </div>
            
            <div class="tool-group">
                <h3>스냅 설정</h3>
                <div class="snap-control">
                    <label>스냅 간격:</label>
                    <input type="number" id="snap-interval" min="0.1" max="10" value="0.2" step="0.1">
                    <span class="unit">mm</span>
                    <div class="info-text">벽 모드에서만 활성화됩니다</div>
                </div>
            </div>
            
            <div class="tool-group">
                <h3>건축 요소</h3>
                <button id="door-left-btn" class="icon-btn" title="왼쪽 여닫이문" draggable="true">
                    <svg xmlns="http://www.w3.org/2000/svg" width="55" height="49" fill="none" viewBox="0 0 55 49">
                      <g clip-path="url(#a-1)"><path stroke="#000" stroke-width="1.3" d="M7 41.6H1v6h6v-6Zm47 0h-6v6h6v-6Zm-6 0H7v6h41v-6ZM7 1v45"/><path stroke="#000" stroke-width="1.3" d="M7 1.6a41 41 0 0 1 41 41"/><path stroke="#000" d="M7 45.1h41"/></g>
                      <defs><clipPath id="a-1"><path fill="#fff" d="M0 0h55v49H0z"/></clipPath></defs>
                    </svg>
                </button>
                <button id="door-right-btn" class="icon-btn" title="오른쪽 여닫이문" draggable="true">
                    <svg xmlns="http://www.w3.org/2000/svg" width="55" height="48" fill="none" viewBox="0 0 55 48">
                      <g clip-path="url(#a-2)"><path stroke="#000" stroke-width="1.3" d="M48 41h6v6h-6v-6ZM1 41h6v6H1v-6Zm6 0h41v6H7v-6ZM48 .4v45"/><path stroke="#000" stroke-width="1.3" d="M48 1A41 41 0 0 0 7 42"/><path stroke="#000" d="M48 44.5H7"/></g>
                      <defs><clipPath id="a-2"><path fill="#fff" d="M55 0H0v48h55z"/></clipPath></defs>
                    </svg>
                </button>
                 <button id="window-left-btn" class="icon-btn" title="왼쪽 창문" draggable="true">
                    <svg xmlns="http://www.w3.org/2000/svg" width="62" height="21" fill="none" viewBox="0 0 62 21">
                      <g clip-path="url(#a-3)"><path stroke="#000" stroke-width="1.3" d="M1 1h60m0 0H1v10h60V1Z"/><path fill="#000" d="m13 17 6.5-3.753v7.506L13 17Zm31 0v.65H18.85v-1.3H44V17Z"/></g>
                      <defs><clipPath id="a-3"><path fill="#fff" d="M0 0h62v21H0z"/></clipPath></defs>
                    </svg>
                </button>
                 <button id="window-right-btn" class="icon-btn" title="오른쪽 창문" draggable="true">
                    <svg xmlns="http://www.w3.org/2000/svg" width="62" height="21" fill="none" viewBox="0 0 62 21">
                      <g clip-path="url(#a-4)"><path stroke="#000" stroke-width="1.3" d="M1 1h60m0 0H1v10h60V1Z"/><path fill="#000" d="m54 17-6.5-3.753v7.506L54 17Zm-31 0v.65h25.15v-1.3H23V17Z"/></g>
                      <defs><clipPath id="a-4"><path fill="#fff" d="M0 0h62v21H0z"/></clipPath></defs>
                    </svg>
                </button>
                 <button id="window-both-btn" class="icon-btn" title="양쪽 창문" draggable="true">
                    <svg xmlns="http://www.w3.org/2000/svg" width="66" height="21" fill="none" viewBox="0 0 66 21">
                      <g clip-path="url(#a-5)"><path stroke="#000" stroke-width="1.3" d="M3 1h60m0 0H3v10h60V1Z"/><path fill="#000" d="m66 17-6.5-3.753v7.506L66 17Zm-31 0v.65h25.15v-1.3H35V17ZM0 17l6.5-3.753v7.506L0 17Zm31 0v.65H5.85v-1.3H31V17Z"/></g>
                      <defs><clipPath id="a-5"><path fill="#fff" d="M0 0h66v21H0z"/></clipPath></defs>
                    </svg>
                </button>
                <button id="door-double-btn" class="icon-btn" title="양개형 여닫이문" draggable="true">
                    <svg xmlns="http://www.w3.org/2000/svg" width="96" height="48" fill="none" viewBox="0 0 96 48">
                      <g clip-path="url(#a-6)"><path stroke="#000" stroke-width="1.3" d="M7 41H1v6h6v-6Zm47 0h-6v6h6v-6Zm-6 0H7v6h41v-6ZM7 .4v45"/><path stroke="#000" stroke-width="1.3" d="M7 1a41 41 0 0 1 41 41"/><path stroke="#000" d="M7 44.5h41"/><path stroke="#000" stroke-width="1.3" d="M89 41h6v6h-6v-6Zm-47 0h6v6h-6v-6Zm6 0h41v6H48v-6ZM89 .4v45"/><path stroke="#000" stroke-width="1.3" d="M89 1a41 41 0 0 0-41 41"/><path stroke="#000" d="M89 44.5H48"/></g>
                      <defs><clipPath id="a-6"><path fill="#fff" d="M0 0h96v48H0z"/></clipPath></defs>
                    </svg>
                </button>
            </div>

            <div class="tool-group">
                <h3>파일</h3>
                <button id="save-btn">저장</button>
                <button id="load-btn">불러오기</button>
                <button id="export-btn">이미지 내보내기</button>
                <button id="clear-btn">전체 삭제</button>
            </div>
            
            <div class="tool-group">
                <h3>배경 이미지</h3>
                <button id="bg-image-btn">이미지 불러오기</button>
                <button id="bg-clear-btn" disabled>이미지 제거</button>
                <div style="margin-top: 10px; display: none;" id="opacity-control">
                    <label style="font-size: 12px;">불투명도: 
                        <input type="range" id="bg-opacity" min="10" max="100" value="50" style="width: 100px; vertical-align: middle;">
                        <span id="opacity-value">50%</span>
                    </label>
                </div>
            </div>
            
            <div class="tool-group">
                <h3>보기</h3>
                <button id="grid-btn">격자 표시</button>
            </div>
        </div>
        
        <div class="main-content">
            <div id="canvas-container">
                <canvas id="canvas"></canvas>
                <div class="size-controls" id="size-controls">
                    <label>너비: <input type="number" id="width-input" min="10" step="5"></label>
                    <label>높이: <input type="number" id="height-input" min="10" step="5"></label>
                    <label>각도: <input type="number" id="angle-input" min="0" max="360" step="15"></label>
                    <label id="stroke-width-control" style="display:none;">선 두께: <input type="number" id="stroke-width-input" min="1" max="20" step="1"></label>
                </div>
                <div class="history-counter" id="history-counter"></div>
                <div class="snap-indicator" id="snap-indicator"></div>
            </div>

            <div id="object-panel">
                <div id="object-panel-header">객체 목록</div>
                <ul id="object-panel-list">
                    <!-- 객체 목록이 여기에 동적으로 추가됩니다 -->
                </ul>
            </div>
        </div>

        <div class="info collapsed" id="info-banner">
            <div class="info-header" id="info-toggle-btn">
                <strong>사용법</strong>
                <span class="toggle-icon">▼</span>
            </div>
            <ul>
                <li><strong>도구 단축키:</strong> 선택(V), 벽(W), 사각형(R), 삭제(Backspace)</li>
                <li><strong>화면 이동:</strong> 스페이스바를 누른 채 드래그 합니다.</li>
                <li><strong>연속 벽 그리기:</strong> 벽 모드에서 첫 선을 드래그로 그은 후, 마우스를 움직이면 자동으로 연장선이 표시됩니다. 클릭하여 벽을 연결하고, ESC 키로 종료합니다.</li>
                <li><strong>객체 선택:</strong> 캔버스에서 직접 클릭하거나, 우측 '객체 목록' 패널에서 항목을 클릭합니다.</li>
                <li><strong>복사/붙여넣기:</strong> 객체 선택 후 Ctrl+C / Ctrl+V 편집 메뉴의 버튼을 사용합니다.</li>
                <li><strong>선 두께 조절:</strong> 상단 툴바에서 기본 두께를 설정하거나, 객체 선택 후 나타나는 컨트롤에서 개별 조절합니다.</li>
                <li><strong>스냅 기능:</strong> 벽 모드에서 기존 선 위의 스냅 포인트에 자동으로 연결됩니다. 스냅 간격은 상단에서 조정 가능합니다.</li>
                <li><strong>건축 요소 삽입:</strong> 아이콘을 클릭 후 캔버스에 클릭하거나, 아이콘을 캔버스로 드래그 앤 드롭합니다.</li>
                <li><strong>확대/축소:</strong> Ctrl(Windows)마우스 휠을 돌려 조절합니다.</li>
                <li><strong>크기 조절:</strong> 객체 모서리를 드래그하여 조절합니다. Shift 키를 누른 채 드래그하면 자율 조절됩니다.</li>
                <li><strong>객체 회전:</strong> 객체 모서리 바깥쪽을 드래그합니다. Shift 키를 누른 채 드래그하면 90도 단위로 회전합니다.</li>
                <li><strong>실행취소/다시실행:</strong> Ctrl+Z / Ctrl+Y 또는 버튼 클릭.</li>
            </ul>
        </div>
    </div>

    <!-- 컨텍스트 메뉴 HTML -->
    <div id="context-menu">
        <button id="flip-btn">좌우 반전</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script>
        const canvasContainer = document.getElementById('canvas-container');
        const canvasEl = document.getElementById('canvas');

        const canvas = new fabric.Canvas('canvas', { backgroundColor: 'white', selection: true, stopContextMenu: true, fireRightClick: true, uniScaleTransform: true, });

        // ======= 스냅 기능 관련 변수 =======
        let snapInterval = 0.2; // 기본 스냅 간격 (mm)
        let snapRadius = 10; // 스냅 반경 (픽셀)
        let snapEnabled = false; // 스냅 활성화 상태
        let snapPoints = []; // 모든 스냅 포인트 저장
        let currentSnapPoint = null; // 현재 활성화된 스냅 포인트
        const snapIndicator = document.getElementById('snap-indicator');
        const snapIntervalInput = document.getElementById('snap-interval');
        
        // ======= 연속 벽 그리기 관련 변수 =======
        let continuousDrawing = false; // 연속 그리기 모드
        let lastWallEndX = null; // 마지막 벽의 끝 X 좌표
        let lastWallEndY = null; // 마지막 벽의 끝 Y 좌표
        let previewLine = null; // 미리보기 선
        // <<< 변경/추가된 부분: Path 객체와 점들을 저장할 변수
        let currentWallPath = null;
        let wallPoints = [];
        
        // 스냅 간격 변경 이벤트
        snapIntervalInput.addEventListener('change', (e) => {
            snapInterval = parseFloat(e.target.value) || 0.2;
            if (snapInterval < 0.1) snapInterval = 0.1;
            if (snapInterval > 10) snapInterval = 10;
            snapIntervalInput.value = snapInterval;
            updateSnapPoints(); // 스냅 포인트 재계산
        });

        // mm를 픽셀로 변환 (1mm = 3.78 pixels at 96 DPI)
        function mmToPixels(mm) {
            return mm * 3.78;
        }

        // 픽셀을 mm로 변환
        function pixelsToMm(pixels) {
            return pixels / 3.78;
        }

        // 선 위의 스냅 포인트 계산
        function getSnapPointsOnLine(line) {
            const points = [];
            // Path 객체는 x1,y1 속성이 없으므로, pathPoints가 있는지 확인
            if (line.path) { // <<< 변경된 부분: Path 객체도 스냅 포인트 계산에 포함
                const pathPoints = line.path.map(p => ({ x: p[1], y: p[2] }));
                for(let i = 0; i < pathPoints.length - 1; i++) {
                    const p1 = pathPoints[i];
                    const p2 = pathPoints[i+1];
                    const length = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                    const intervalPixels = mmToPixels(snapInterval);
                    const numPoints = Math.floor(length / intervalPixels);
                     for (let j = 0; j <= numPoints; j++) {
                        const t = j / numPoints;
                        const x = p1.x + (p2.x - p1.x) * t;
                        const y = p1.y + (p2.y - p1.y) * t;
                        points.push({ x, y, line: line });
                    }
                }
                 points.push({ x: pathPoints[pathPoints.length-1].x, y: pathPoints[pathPoints.length-1].y, line: line });

            } else if (line.type === 'line') {
                const x1 = line.x1, y1 = line.y1, x2 = line.x2, y2 = line.y2;
                const matrix = line.calcTransformMatrix();
                const p1 = fabric.util.transformPoint({ x: x1, y: y1 }, matrix);
                const p2 = fabric.util.transformPoint({ x: x2, y: y2 }, matrix);
                const length = Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
                const intervalPixels = mmToPixels(snapInterval);
                const numPoints = Math.floor(length / intervalPixels) + 1;
                for (let i = 0; i <= numPoints; i++) {
                    const t = i / numPoints;
                    const x = p1.x + (p2.x - p1.x) * t;
                    const y = p1.y + (p2.y - p1.y) * t;
                    points.push({ x, y, line: line });
                }
            }
            return points;
        }

        // 모든 스냅 포인트 업데이트
        function updateSnapPoints() {
            snapPoints = [];
            canvas.getObjects().forEach(obj => {
                if ((obj.type === 'line' || obj.type === 'path') && !obj.isGridLine) { // Path도 포함
                    const points = getSnapPointsOnLine(obj);
                    snapPoints = snapPoints.concat(points);
                }
            });
        }

        // 가장 가까운 스냅 포인트 찾기
        function findNearestSnapPoint(x, y) {
            let minDistance = Infinity;
            let nearestPoint = null;
            
            const zoom = canvas.getZoom();
            const vpt = canvas.viewportTransform;
            
            const screenX = x * zoom + vpt[4];
            const screenY = y * zoom + vpt[5];
            
            snapPoints.forEach(point => {
                const pointScreenX = point.x * zoom + vpt[4];
                const pointScreenY = point.y * zoom + vpt[5];
                
                const distance = Math.sqrt(
                    Math.pow(screenX - pointScreenX, 2) + 
                    Math.pow(screenY - pointScreenY, 2)
                );
                
                if (distance < minDistance && distance <= snapRadius) {
                    minDistance = distance;
                    nearestPoint = point;
                }
            });
            
            return nearestPoint;
        }

        // 스냅 인디케이터 표시/숨김
        function showSnapIndicator(x, y) {
            const zoom = canvas.getZoom();
            const vpt = canvas.viewportTransform;
            snapIndicator.style.left = (x * zoom + vpt[4]) + 'px';
            snapIndicator.style.top = (y * zoom + vpt[5]) + 'px';
            snapIndicator.style.display = 'block';
        }

        function hideSnapIndicator() {
            snapIndicator.style.display = 'none';
        }

        const history = {
            states: [], currentIndex: -1, maxSize: 50, isRestoring: false,
            saveState() { if (this.isRestoring) return; this.states = this.states.slice(0, this.currentIndex + 1); const state = JSON.stringify(canvas.toJSON(['elementType'])); this.states.push(state); if (this.states.length > this.maxSize) { this.states.shift(); } else { this.currentIndex++; } this.updateButtons(); this.updateCounter(); updateObjectPanel(); updateSnapPoints(); },
            undo() { if (this.currentIndex > 0) { this.currentIndex--; this.restore(this.states[this.currentIndex]); } },
            redo() { if (this.currentIndex < this.states.length - 1) { this.currentIndex++; this.restore(this.states[this.currentIndex]); } },
            restore(state) { this.isRestoring = true; const vpt = canvas.viewportTransform; canvas.loadFromJSON(state, () => { canvas.viewportTransform = vpt; canvas.renderAll(); if (showGrid) drawGrid(); updateObjectPanel(); updateSnapPoints(); this.isRestoring = false; this.updateButtons(); this.updateCounter(); }); },
            updateButtons() { undoBtn.disabled = this.currentIndex <= 0; redoBtn.disabled = this.currentIndex >= this.states.length - 1; },
            updateCounter() { const counter = document.getElementById('history-counter'); counter.textContent = `${this.currentIndex + 1} / ${this.states.length}`; }
        };

        const gridSize = 20;
        let showGrid = false, currentMode = 'select', isDrawing = false;
        let startX, startY, currentLine = null, selectedObject = null;
        let isPanning = false, lastPosX, lastPosY, spacebarDown = false;
        let backgroundImage = null;
        let defaultStrokeWidth = 2;
        let _clipboard = null;
        
        const objectPanelList = document.getElementById('object-panel-list');
        const bgImageBtn = document.getElementById('bg-image-btn'), bgClearBtn = document.getElementById('bg-clear-btn'), bgOpacity = document.getElementById('bg-opacity'), opacityValue = document.getElementById('opacity-value'), opacityControl = document.getElementById('opacity-control');
        const selectBtn = document.getElementById('select-mode'), wallBtn = document.getElementById('wall-mode'), rectBtn = document.getElementById('rect-mode'), textBtn = document.getElementById('text-mode'), deleteBtn = document.getElementById('delete-btn');
        
        const doorLeftBtn = document.getElementById('door-left-btn');
        const doorRightBtn = document.getElementById('door-right-btn');
        const windowLeftBtn = document.getElementById('window-left-btn');
        const windowRightBtn = document.getElementById('window-right-btn');
        const windowBothBtn = document.getElementById('window-both-btn');
        const doorDoubleBtn = document.getElementById('door-double-btn');

        const gridBtn = document.getElementById('grid-btn');
        const copyBtn = document.getElementById('copy-btn');
        const pasteBtn = document.getElementById('paste-btn');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        
        const sizeControls = document.getElementById('size-controls'), widthInput = document.getElementById('width-input'), heightInput = document.getElementById('height-input'), angleInput = document.getElementById('angle-input');
        const defaultStrokeInput = document.getElementById('default-stroke-width');
        const strokeWidthControl = document.getElementById('stroke-width-control');
        const strokeWidthInput = document.getElementById('stroke-width-input');

        defaultStrokeInput.addEventListener('change', (e) => {
            defaultStrokeWidth = parseInt(e.target.value, 10);
        });

        history.saveState();

        canvas.on({ 'object:added': () => { if (!history.isRestoring) history.saveState(); }, 'object:modified': () => history.saveState(), 'object:removed': () => { if (!history.isRestoring) history.saveState(); } });
        
        function createObject(type, x, y, callback) {
            let svgString = '';
            let defaultWidth = 80;
            let elementType = type;

            switch(type) {
                case 'door-left': svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="55" height="49" fill="none" viewBox="0 0 55 49"><g><path stroke="#000" stroke-width="1.3" d="M7 41.6H1v6h6v-6Zm47 0h-6v6h6v-6Zm-6 0H7v6h41v-6ZM7 1v45"/><path stroke="#000" stroke-width="1.3" d="M7 1.6a41 41 0 0 1 41 41"/><path stroke="#000" d="M7 45.1h41"/></g></svg>`; elementType = '왼쪽 여닫이문'; break;
                case 'door-right': svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="55" height="48" fill="none" viewBox="0 0 55 48"><g><path stroke="#000" stroke-width="1.3" d="M48 41h6v6h-6v-6ZM1 41h6v6H1v-6Zm6 0h41v6H7v-6ZM48 .4v45"/><path stroke="#000" stroke-width="1.3" d="M48 1A41 41 0 0 0 7 42"/><path stroke="#000" d="M48 44.5H7"/></g></svg>`; elementType = '오른쪽 여닫이문'; break;
                case 'window-left': svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="62" height="21" fill="none" viewBox="0 0 62 21"><g><path stroke="#000" stroke-width="1.3" d="M1 1h60m0 0H1v10h60V1Z"/><path fill="#000" d="m13 17 6.5-3.753v7.506L13 17Zm31 0v.65H18.85v-1.3H44V17Z"/></g></svg>`; elementType = '왼쪽 창문'; break;
                case 'window-right': svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="62" height="21" fill="none" viewBox="0 0 62 21"><g><path stroke="#000" stroke-width="1.3" d="M1 1h60m0 0H1v10h60V1Z"/><path fill="#000" d="m54 17-6.5-3.753v7.506L54 17Zm-31 0v.65h25.15v-1.3H23V17Z"/></g></svg>`; elementType = '오른쪽 창문'; break;
                case 'window-both': svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="66" height="21" fill="none" viewBox="0 0 66 21"><g><path stroke="#000" stroke-width="1.3" d="M3 1h60m0 0H3v10h60V1Z"/><path fill="#000" d="m66 17-6.5-3.753v7.506L66 17Zm-31 0v.65h25.15v-1.3H35V17ZM0 17l6.5-3.753v7.506L0 17Zm31 0v.65H5.85v-1.3H31V17Z"/></g></svg>`; elementType = '양쪽 창문'; break;
                case 'door-double': svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="96" height="48" fill="none" viewBox="0 0 96 48"><g><path stroke="#000" stroke-width="1.3" d="M7 41H1v6h6v-6Zm47 0h-6v6h6v-6Zm-6 0H7v6h41v-6ZM7 .4v45"/><path stroke="#000" stroke-width="1.3" d="M7 1a41 41 0 0 1 41 41"/><path stroke="#000" d="M7 44.5h41"/><path stroke="#000" stroke-width="1.3" d="M89 41h6v6h-6v-6Zm-47 0h6v6h-6v-6Zm6 0h41v6H48v-6ZM89 .4v45"/><path stroke="#000" stroke-width="1.3" d="M89 1a41 41 0 0 0-41 41"/><path stroke="#000" d="M89 44.5H48"/></g></svg>`; defaultWidth = 120; elementType = '양개형 여닫이문'; break;
                default: callback(null); return;
            }

            fabric.loadSVGFromString(svgString, (objects, options) => {
                objects.forEach(obj => { if (obj.stroke) obj.set('strokeWidth', defaultStrokeWidth); });
                const group = new fabric.Group(objects, { left: x, top: y, originX: 'center', originY: 'center', elementType: elementType });
                group.scaleToWidth(defaultWidth);
                callback(group);
            });
        }
        
        function setMode(mode) { 
            if (['wall', 'rect', 'text'].includes(mode)) {
                canvas.discardActiveObject().renderAll();
            }
            
            currentMode = mode; 
            
            snapEnabled = (mode === 'wall');
            if (!snapEnabled) {
                hideSnapIndicator();
            }
            
            // <<< 변경된 부분: 벽 모드가 아니면 Path 그리기 관련 변수 초기화
            if (mode !== 'wall') {
                continuousDrawing = false;
                lastWallEndX = null;
                lastWallEndY = null;
                wallPoints = []; 
                if (previewLine) {
                    canvas.remove(previewLine);
                    previewLine = null;
                }
                if(currentWallPath) {
                    currentWallPath.set({ selectable: true });
                    currentWallPath = null;
                }
            }
            
            document.querySelectorAll('button.active').forEach(btn => btn.classList.remove('active')); 
            const currentBtn = document.getElementById(mode + '-mode') || document.getElementById(mode + '-btn'); 
            if (currentBtn) currentBtn.classList.add('active'); 
            canvas.selection = mode === 'select'; 
            canvas.forEachObject(obj => { if (!obj.isGridLine) obj.selectable = (mode === 'select'); }); 
            canvas.renderAll(); 
        }

        document.addEventListener('keydown', (e) => { 
            if (e.target.tagName === 'INPUT' || e.repeat) return;
            
            if (e.code === 'Space') {
                e.preventDefault();
                spacebarDown = true;
                if (!isPanning) {
                    canvas.setCursor('grab');
                }
            }
            
            // <<< 변경된 부분: ESC 키 누를 때 Path 그리기 종료 처리
            if (e.code === 'Escape' && currentMode === 'wall' && continuousDrawing) {
                e.preventDefault();
                continuousDrawing = false;
                lastWallEndX = null;
                lastWallEndY = null;
                
                if (previewLine) {
                    canvas.remove(previewLine);
                    previewLine = null;
                }
                if (currentWallPath) {
                    currentWallPath.set({ selectable: true, evented: true });
                    history.saveState(); // Path가 최종 확정되면 히스토리 저장
                }
                
                wallPoints = [];
                currentWallPath = null;

                hideSnapIndicator();
                canvas.renderAll();
                setMode('select');
            }

            const isCtrlOrCmd = e.ctrlKey || e.metaKey;

            if (isCtrlOrCmd) {
                if (e.key === 'z' || e.key === 'Z') { e.preventDefault(); history.undo(); } 
                if (e.key === 'y' || e.key === 'Y') { e.preventDefault(); history.redo(); }
                if (e.key === 'c' || e.key === 'C') { e.preventDefault(); copyObject(); }
                if (e.key === 'v' || e.key === 'V') { e.preventDefault(); pasteObject(); }
            } else {
                switch(e.code) {
                    case 'Backspace': e.preventDefault(); deleteSelectedObjects(); break;
                    case 'KeyV': setMode('select'); break;
                    case 'KeyW': setMode('wall'); break;
                    case 'KeyR': setMode('rect'); break;
                }
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                spacebarDown = false;
                if (isPanning && !e.buttons) {
                    isPanning = false;
                    canvas.setCursor('default');
                } else if (!isPanning) {
                    canvas.setCursor('default');
                }
            }
        });

        canvas.on('mouse:wheel', (opt) => { 
            if (opt.e.ctrlKey || opt.e.metaKey) { 
                const delta = opt.e.deltaY; let zoom = canvas.getZoom(); zoom *= 0.999 ** delta; if (zoom > 20) zoom = 20; if (zoom < 0.1) zoom = 0.1; canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom); opt.e.preventDefault(); opt.e.stopPropagation(); 
            } 
        });
        
        const contextMenu = document.getElementById('context-menu');
        const flipBtn = document.getElementById('flip-btn');
        let rightClickedObject = null;

        // <<< 변경된 부분: 벽 그리기 로직을 Path 기반으로 전면 수정
        canvas.on('mouse:down', (e) => {
            contextMenu.style.display = 'none';
            if (e.button === 3) {
                const target = e.target;
                if (target && target.isType('group') && target.elementType) {
                    e.e.preventDefault();
                    rightClickedObject = target;
                    contextMenu.style.left = `${e.e.clientX}px`;
                    contextMenu.style.top = `${e.e.clientY}px`;
                    contextMenu.style.display = 'block';
                    return;
                }
            }
            const isMiddleClick = e.e.button === 1;
            const isSpacebarPan = spacebarDown && e.e.button === 0;
            if (isMiddleClick || isSpacebarPan) {
                isPanning = true;
                lastPosX = e.e.clientX;
                lastPosY = e.e.clientY;
                canvas.setCursor('grabbing');
                canvas.discardActiveObject();
                canvas.selection = false;
                canvas.renderAll();
                return;
            }
            if (currentMode === 'select') return;
            
            const pointer = canvas.getPointer(e.e); 
            
            // 벽(Path) 그리기 로직
            if (currentMode === 'wall') {
                let currentX = pointer.x;
                let currentY = pointer.y;

                if (snapEnabled) {
                    const snapPoint = findNearestSnapPoint(pointer.x, pointer.y);
                    if (snapPoint) {
                        currentX = snapPoint.x;
                        currentY = snapPoint.y;
                    }
                }

                // 연속 그리기를 시작 (첫 클릭)
                if (!continuousDrawing) {
                    continuousDrawing = true;
                    wallPoints.push({ x: currentX, y: currentY });
                    lastWallEndX = currentX;
                    lastWallEndY = currentY;
                    // 미리보기 선을 생성
                    previewLine = new fabric.Line([lastWallEndX, lastWallEndY, lastWallEndX, lastWallEndY], {
                        stroke: 'gray', strokeWidth: defaultStrokeWidth, strokeDashArray: [5, 5],
                        selectable: false, evented: false,
                    });
                    canvas.add(previewLine);
                } 
                // 연속해서 점을 추가 (두 번째 클릭부터)
                else {
                    wallPoints.push({ x: currentX, y: currentY });
                    
                    // 기존 Path가 있으면 제거
                    if (currentWallPath) {
                        canvas.remove(currentWallPath);
                    }
                    
                    // Path 데이터 생성 (M x1 y1 L x2 y2 ...)
                    const pathData = wallPoints.map((p, i) => (i === 0 ? 'M' : 'L') + ` ${p.x} ${p.y}`).join(' ');

                    currentWallPath = new fabric.Path(pathData, {
                        stroke: 'black',
                        strokeWidth: defaultStrokeWidth,
                        strokeLineJoin: 'miter', // 모서리를 날카롭게!
                        fill: 'transparent', // 채우기 없음
                        selectable: false, // 그리는 중에는 선택 안되게
                        evented: false,
                        elementType: '벽'
                    });
                    canvas.add(currentWallPath);
                    
                    lastWallEndX = currentX;
                    lastWallEndY = currentY;
                }
                canvas.renderAll();
                return;
            }
            
            // 다른 모드들 처리
            startX = pointer.x; startY = pointer.y; isDrawing = true;
            switch(currentMode) {
                case 'rect': currentLine = new fabric.Rect({ left: startX, top: startY, width: 0, height: 0, fill: 'transparent', stroke: 'black', strokeWidth: defaultStrokeWidth, strokeDashArray: [5, 5] }); canvas.add(currentLine); break;
                case 'text': const text = prompt('텍스트를 입력하세요:'); if (text) { const insertedObject = new fabric.Text(text, { left: startX, top: startY, fontSize: 14, fill: 'black' }); canvas.add(insertedObject); setMode('select'); canvas.setActiveObject(insertedObject); } isDrawing = false; break;
                case 'door-left': case 'door-right': case 'window-left': case 'window-right': case 'window-both': case 'door-double':
                    createObject(currentMode, startX, startY, (insertedObject) => {
                        if (insertedObject) { canvas.add(insertedObject); setMode('select'); canvas.setActiveObject(insertedObject); canvas.renderAll(); }
                    });
                    isDrawing = false;
                    break;
            }
        });
        
        flipBtn.addEventListener('click', () => {
            if (rightClickedObject) {
                rightClickedObject.set('flipX', !rightClickedObject.flipX);
                canvas.renderAll();
                history.saveState();
            }
            contextMenu.style.display = 'none';
        });

        window.addEventListener('click', (e) => {
            if (!contextMenu.contains(e.target)) {
                contextMenu.style.display = 'none';
            }
        });

        canvas.on('mouse:move', (e) => {
            if (isPanning) { const vpt = canvas.viewportTransform; vpt[4] += e.e.clientX - lastPosX; vpt[5] += e.e.clientY - lastPosY; canvas.requestRenderAll(); lastPosX = e.e.clientX; lastPosY = e.e.clientY; return; }
            
            const pointer = canvas.getPointer(e.e);
            
            // <<< 변경된 부분: 벽 그리기 시 미리보기 선만 업데이트
            if (currentMode === 'wall' && continuousDrawing && previewLine) {
                let endX = pointer.x, endY = pointer.y;
                
                if (snapEnabled) {
                    const snapPoint = findNearestSnapPoint(pointer.x, pointer.y);
                    if (snapPoint) { endX = snapPoint.x; endY = snapPoint.y; showSnapIndicator(endX, endY); } 
                    else { hideSnapIndicator(); }
                }
                
                if (e.e.shiftKey) {
                    const dx = Math.abs(endX - lastWallEndX);
                    const dy = Math.abs(endY - lastWallEndY);
                    if (dx > dy) { endY = lastWallEndY; } else { endX = lastWallEndX; }
                }
                
                previewLine.set({ x2: endX, y2: endY });
                canvas.renderAll();
                return;
            }
            
            if (snapEnabled && currentMode === 'wall' && !continuousDrawing) {
                const snapPoint = findNearestSnapPoint(pointer.x, pointer.y);
                if (snapPoint) { showSnapIndicator(snapPoint.x, snapPoint.y); currentSnapPoint = snapPoint; } 
                else { hideSnapIndicator(); currentSnapPoint = null; }
            }
            
            if (!isDrawing) return;
            
            // 사각형 그리기 로직 (벽 그리기는 mouse:down에서 처리되므로 여기선 제외)
            if (currentMode === 'rect' && currentLine) { 
                const width = Math.abs(pointer.x - startX); 
                const height = Math.abs(pointer.y - startY); 
                currentLine.set({ left: Math.min(pointer.x, startX), top: Math.min(pointer.y, startY), width: width, height: height }); 
                canvas.renderAll(); 
            }
        });

        // <<< 변경된 부분: mouse:up은 이제 사각형 그리기만 처리
        canvas.on('mouse:up', (e) => {
            if (isPanning) { 
                isPanning = false; 
                canvas.selection = (currentMode === 'select');
                canvas.setCursor(spacebarDown ? 'grab' : 'default'); 
                return; 
            }
            if (!isDrawing) return;
            
            let newObject = null;
            if (currentMode === 'rect' && currentLine) { 
                canvas.remove(currentLine); 
                const pointer = canvas.getPointer(e.e); 
                const width = Math.abs(pointer.x - startX); 
                const height = Math.abs(pointer.y - startY); 
                if (width > 2 && height > 2) { 
                    newObject = new fabric.Rect({ left: Math.min(startX, pointer.x), top: Math.min(startY, pointer.y), width, height, fill: 'transparent', stroke: 'black', strokeWidth: defaultStrokeWidth, elementType: '사각형' }); 
                    canvas.add(newObject); 
                } 
            }
            
            if(newObject) { 
                setMode('select'); 
                canvas.setActiveObject(newObject); 
            }
            
            isDrawing = false; 
            currentLine = null;
        });

        function handleRotating(opt) {
            if (opt.e.shiftKey) {
                const target = opt.target;
                const snappedAngle = Math.round(target.angle / 90) * 90;
                target.set('angle', snappedAngle);
            }
            updateSizeControls();
        }

        canvas.on({ 
            'selection:created': (e) => updateSelection(e.selected), 
            'selection:updated': (e) => updateSelection(e.selected), 
            'selection:cleared': () => updateSelection([]), 
            'object:scaling': updateSizeControls,
            'object:rotating': handleRotating
        });

        function updateSelection(selected) { 
            highlightPanelSelection(); 
            selectedObject = selected.length === 1 ? selected[0] : null; 
            
            copyBtn.disabled = !selectedObject;
            
            if (selectedObject) { 
                sizeControls.classList.add('show'); 
                updateSizeControls(); 
                // Path 객체도 선 두께 조절 가능
                if (selectedObject.type === 'line' || selectedObject.type === 'rect' || selectedObject.isType('group') || selectedObject.type === 'path') {
                    strokeWidthControl.style.display = 'block';
                } else {
                    strokeWidthControl.style.display = 'none';
                }
            } else { 
                sizeControls.classList.remove('show'); 
            } 
        }

        function updateSizeControls() { 
            if (selectedObject) { 
                widthInput.value = Math.round(selectedObject.getScaledWidth()); 
                heightInput.value = Math.round(selectedObject.getScaledHeight()); 
                angleInput.value = Math.round(selectedObject.angle); 
                
                if (selectedObject.type === 'line' || selectedObject.type === 'rect' || selectedObject.type === 'path') {
                    strokeWidthInput.value = selectedObject.strokeWidth;
                } else if (selectedObject.isType('group')) {
                    const firstStroked = selectedObject.getObjects().find(o => o.stroke);
                    if (firstStroked) {
                        strokeWidthInput.value = firstStroked.strokeWidth;
                    }
                }
            } 
        }
        widthInput.addEventListener('input', () => { if (selectedObject) { selectedObject.scaleToWidth(parseInt(widthInput.value, 10)); canvas.renderAll(); }});
        heightInput.addEventListener('input', () => { if (selectedObject) { selectedObject.scaleToHeight(parseInt(heightInput.value, 10)); canvas.renderAll(); }});
        angleInput.addEventListener('input', () => { if (selectedObject) { selectedObject.set('angle', parseInt(angleInput.value, 10)).setCoords(); canvas.renderAll(); }});
        
        strokeWidthInput.addEventListener('input', () => {
            if (!selectedObject) return;
            const newWidth = parseInt(strokeWidthInput.value, 10);
            if(isNaN(newWidth) || newWidth < 1) return;

            if (selectedObject.type === 'line' || selectedObject.type === 'rect' || selectedObject.type === 'path') {
                selectedObject.set('strokeWidth', newWidth);
            } else if (selectedObject.isType('group')) {
                selectedObject.getObjects().forEach(obj => {
                    if (obj.stroke) {
                        obj.set('strokeWidth', newWidth);
                    }
                });
            }
            canvas.renderAll();
            history.saveState();
        });
        
        selectBtn.addEventListener('click', () => setMode('select')); wallBtn.addEventListener('click', () => setMode('wall')); rectBtn.addEventListener('click', () => setMode('rect')); textBtn.addEventListener('click', () => setMode('text'));
        doorLeftBtn.addEventListener('click', () => setMode('door-left')); doorRightBtn.addEventListener('click', () => setMode('door-right')); windowLeftBtn.addEventListener('click', () => setMode('window-left')); windowRightBtn.addEventListener('click', () => setMode('window-right')); windowBothBtn.addEventListener('click', () => setMode('window-both')); doorDoubleBtn.addEventListener('click', () => setMode('door-double'));
        
        copyBtn.addEventListener('click', copyObject);
        pasteBtn.addEventListener('click', pasteObject);
        undoBtn.addEventListener('click', () => history.undo()); 
        redoBtn.addEventListener('click', () => history.redo()); 
        deleteBtn.addEventListener('click', deleteSelectedObjects);

        function deleteSelectedObjects() { 
            canvas.getActiveObjects().forEach(obj => canvas.remove(obj)); 
            canvas.discardActiveObject().renderAll(); 
        }
        
        function copyObject() {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                activeObject.clone(function(cloned) {
                    _clipboard = cloned;
                    pasteBtn.disabled = false;
                }, ['elementType']);
            }
        }

        function pasteObject() {
            if (!_clipboard) return;

            _clipboard.clone(function(clonedObj) {
                canvas.discardActiveObject();
                
                clonedObj.set({
                    left: clonedObj.left + 15,
                    top: clonedObj.top + 15,
                    evented: true,
                });

                if (clonedObj.isType('group')) {
                    clonedObj.getObjects().forEach(function(obj) {
                        const originalObj = _clipboard.getObjects().find(o => o.type === obj.type);
                        if(originalObj && originalObj.strokeWidth) {
                             obj.set('strokeWidth', originalObj.strokeWidth);
                        }
                    });
                }
                
                canvas.add(clonedObj);
                canvas.setActiveObject(clonedObj);
                canvas.requestRenderAll();
            }, ['elementType']);
        }

        function updateObjectPanel() {
            objectPanelList.innerHTML = '';
            const objects = canvas.getObjects().filter(obj => !obj.isGridLine);
            objects.forEach((obj, index) => {
                const li = document.createElement('li');
                let name = obj.elementType || obj.type || '객체';
                if(obj.type === 'text') name = `텍스트: ${obj.text.substring(0, 10)}...`;
                // Path 객체도 '벽'으로 표시
                else if(obj.type === 'path' && obj.elementType === '벽') name = `벽 ${index + 1}`;
                else if(obj.type === 'rect') name = `사각형 ${index + 1}`;
                else name = `${name} ${index + 1}`;
                li.textContent = name;
                li.dataset.objectIndex = canvas.getObjects().indexOf(obj); 
                li.addEventListener('click', () => { canvas.discardActiveObject(); canvas.setActiveObject(obj); canvas.renderAll(); });
                objectPanelList.appendChild(li);
            });
            highlightPanelSelection();
        }

        function highlightPanelSelection() {
            const activeObjects = canvas.getActiveObjects();
            const listItems = objectPanelList.querySelectorAll('li');
            listItems.forEach(li => {
                const objIndex = parseInt(li.dataset.objectIndex, 10);
                const obj = canvas.getObjects()[objIndex];
                if (activeObjects.includes(obj)) { li.classList.add('selected'); } else { li.classList.remove('selected'); }
            });
        }

        const draggableElements = ['door-left-btn', 'door-right-btn', 'window-left-btn', 'window-right-btn', 'window-both-btn', 'door-double-btn'];
        draggableElements.forEach(id => { const el = document.getElementById(id); el.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', id.replace('-btn', '')); }); });
        canvasContainer.addEventListener('dragover', (e) => e.preventDefault());
        canvasContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            const type = e.dataTransfer.getData('text/plain');
            const zoom = canvas.getZoom();
            const panX = canvas.viewportTransform[4]; const panY = canvas.viewportTransform[5];
            const centerX = (canvas.width / 2 - panX) / zoom; const centerY = (canvas.height / 2 - panY) / zoom;
            
            createObject(type, centerX, centerY, (newObject) => {
                if (newObject) { canvas.add(newObject); setMode('select'); canvas.setActiveObject(newObject); canvas.renderAll(); }
            });
        });
        
        document.getElementById('clear-btn').addEventListener('click', () => { if (confirm('모든 내용을 삭제하시겠습니까?\n(배경 이미지도 함께 제거됩니다)')) { history.isRestoring = true; canvas.clear(); canvas.setViewportTransform([1, 0, 0, 1, 0, 0]); canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas)); canvas.backgroundColor = 'white'; backgroundImage = null; bgClearBtn.disabled = true; opacityControl.style.display = 'none'; if (showGrid) drawGrid(); history.isRestoring = false; history.saveState(); } });
        bgImageBtn.addEventListener('click', () => { const input = document.createElement('input'); input.type = 'file'; input.accept = 'image/*'; input.onchange = (e) => { const reader = new FileReader(); reader.onload = (event) => { fabric.Image.fromURL(event.target.result, (img) => { const scale = Math.min(canvas.width / img.width, canvas.height / img.height); img.set({ scaleX: scale, scaleY: scale, opacity: bgOpacity.value / 100 }); canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas), { originX: 'left', originY: 'top' }); backgroundImage = img; bgClearBtn.disabled = false; opacityControl.style.display = 'block'; }); }; reader.readAsDataURL(e.target.files[0]); }; input.click(); });
        bgClearBtn.addEventListener('click', () => { canvas.setBackgroundImage(null, canvas.renderAll.bind(canvas)); backgroundImage = null; bgClearBtn.disabled = true; opacityControl.style.display = 'none'; });
        bgOpacity.addEventListener('input', (e) => { const opacity = e.target.value; opacityValue.textContent = opacity + '%'; if (backgroundImage) { backgroundImage.set('opacity', opacity / 100); canvas.renderAll(); } });
        
        function drawGrid() { canvas.getObjects().forEach(o => { if (o.isGridLine) canvas.remove(o) }); const zoom = canvas.getZoom(); const panX = canvas.viewportTransform[4]; const panY = canvas.viewportTransform[5]; for (let i = Math.floor(-panX / (gridSize * zoom)); i * gridSize < canvas.width / zoom; i++) { const x = i * gridSize; const line = new fabric.Line([x, -panY / zoom, x, (canvas.height - panY) / zoom], { stroke: '#e0e0e0', strokeWidth: 1, selectable: false, evented: false, isGridLine: true }); canvas.add(line); } for (let i = Math.floor(-panY / (gridSize * zoom)); i * gridSize < canvas.height / zoom; i++) { const y = i * gridSize; const line = new fabric.Line([-panX / zoom, y, (canvas.width - panX) / zoom, y], { stroke: '#e0e0e0', strokeWidth: 1, selectable: false, evented: false, isGridLine: true }); canvas.add(line); } canvas.getObjects().filter(o => o.isGridLine).forEach(o => canvas.sendToBack(o)); }
        canvas.on('after:render', () => { if (showGrid) drawGrid(); });
        gridBtn.addEventListener('click', () => { showGrid = !showGrid; gridBtn.classList.toggle('active', showGrid); if (!showGrid) { canvas.getObjects().forEach(o => { if(o.isGridLine) canvas.remove(o) }); } canvas.renderAll(); });
        
        document.getElementById('export-btn').addEventListener('click', () => {
            const tempBg = canvas.backgroundImage;
            const doExport = () => { const link = document.createElement('a'); link.download = '평면도.png'; link.href = canvas.toDataURL({ format: 'png', quality: 1 }); link.click(); };
            if (tempBg) { canvas.setBackgroundImage(null, () => { doExport(); canvas.setBackgroundImage(tempBg, canvas.renderAll.bind(canvas)); }); } 
            else { doExport(); }
        });

        document.getElementById('save-btn').addEventListener('click', () => { 
            const data = { 
                version: '3.0', canvas: canvas.toJSON(['elementType']), viewport: canvas.viewportTransform, 
                backgroundImage: backgroundImage ? { src: canvas.backgroundImage._element.src, opacity: backgroundImage.opacity, scaleX: backgroundImage.scaleX, scaleY: backgroundImage.scaleY } : null, 
                defaultStrokeWidth: defaultStrokeWidth, snapInterval: snapInterval 
            }; 
            const blob = new Blob([JSON.stringify(data)], { type: 'application/json' }); 
            const url = URL.createObjectURL(blob); 
            const link = document.createElement('a'); link.download = '평면도.json'; link.href = url; link.click(); 
            URL.revokeObjectURL(url); 
        });
        
        document.getElementById('load-btn').addEventListener('click', () => { 
            const input = document.createElement('input'); input.type = 'file'; input.accept = '.json'; 
            input.onchange = (e) => { 
                const reader = new FileReader(); 
                reader.onload = (event) => { 
                    const data = JSON.parse(event.target.result); 
                    history.isRestoring = true; 
                    canvas.loadFromJSON(data.canvas || data, () => { 
                        if (data.viewport) canvas.setViewportTransform(data.viewport); 
                        if (data.backgroundImage) { 
                            fabric.Image.fromURL(data.backgroundImage.src, (img) => { 
                                img.set(data.backgroundImage); canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas)); 
                                backgroundImage = img; bgClearBtn.disabled = false; opacityControl.style.display = 'block'; 
                                bgOpacity.value = (data.backgroundImage.opacity || 1) * 100; 
                                opacityValue.textContent = `${Math.round(bgOpacity.value)}%`; 
                            }); 
                        } 
                        if (data.defaultStrokeWidth) { defaultStrokeWidth = data.defaultStrokeWidth; defaultStrokeInput.value = defaultStrokeWidth; }
                        if (data.snapInterval) { snapInterval = data.snapInterval; snapIntervalInput.value = snapInterval; }
                        canvas.renderAll(); updateSnapPoints(); history.isRestoring = false; history.saveState(); 
                    }); 
                }; 
                reader.readAsText(e.target.files[0]); 
            }; 
            input.click(); 
        });
        
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;
            canvasEl.width = width; canvasEl.height = height;
            canvas.setWidth(width); canvas.setHeight(height);
            canvas.renderAll();
        }

        const resizeObserver = new ResizeObserver(entries => { resizeCanvas(); });
        resizeObserver.observe(canvasContainer);
        resizeCanvas();

        const infoBanner = document.getElementById('info-banner');
        const infoToggleBtn = document.getElementById('info-toggle-btn');
        infoToggleBtn.addEventListener('click', () => { infoBanner.classList.toggle('collapsed'); });

        setMode('select');
    </script>
</body>
</html>
