<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CAD 스타일 평면도 편집기</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Malgun Gothic', sans-serif;
            background-color: #f0f0f0;
        }

        .container {
            max-width: 1400px; 
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        
        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tool-group {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            background-color: #f9f9f9;
        }
        
        .tool-group h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
        }
        
        button {
            padding: 8px 15px;
            border: 1px solid #ddd;
            background-color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            margin: 2px;
            position: relative;
        }
        
        button:hover {
            background-color: #e0e0e0;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        button.active {
            background-color: #4CAF50;
            color: white;
        }
        
        .icon-btn {
            width: 50px;
            height: 50px;
            padding: 5px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        
        .icon-btn svg {
            width: 30px;
            height: 30px;
        }
        
        .icon-btn span {
            font-size: 10px;
            margin-top: 2px;
        }

        .main-content {
            display: flex;
            gap: 20px;
        }

        #canvas-container {
            flex-grow: 1;
            border: 2px solid #ddd;
            border-radius: 4px;
            background-color: white;
            position: relative;
            overflow: hidden; 
            height: 700px; 
        }

        #object-panel {
            width: 240px;
            flex-shrink: 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
            display: flex;
            flex-direction: column;
        }

        #object-panel-header {
            padding: 10px;
            font-weight: bold;
            border-bottom: 1px solid #ddd;
            background-color: #f0f0f0;
        }

        #object-panel-list {
            list-style: none;
            margin: 0;
            padding: 0;
            overflow-y: auto;
            flex-grow: 1;
        }

        #object-panel-list li {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #object-panel-list li:hover {
            background-color: #e0e0e0;
        }
        
        #object-panel-list li.selected {
            background-color: #4CAF50;
            color: white;
            font-weight: bold;
        }
        
        .size-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255,255,255,0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            display: none;
            z-index: 10;
        }
        
        .size-controls.show { display: block; }
        
        .size-controls label { display: block; margin-bottom: 5px; font-size: 12px; }
        .size-controls input { width: 60px; margin-left: 5px; }
        
        .info { margin-top: 20px; padding: 15px; background-color: #e8f4f8; border-radius: 4px; font-size: 14px; }
        .shortcut { color: #666; font-size: 11px; margin-left: 5px; }
        
        .history-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 12px;
            color: #666;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CAD 스타일 평면도 편집기</h1>

        <div class="toolbar">
             <div class="tool-group">
                <h3>기본 도구</h3>
                <button id="select-mode" class="active">선택<span class="shortcut">V</span></button>
                <button id="wall-mode">벽</button>
                <button id="rect-mode">사각형</button>
                <button id="text-mode">텍스트</button>
                <button id="delete-btn">삭제<span class="shortcut">Backspace</span></button>
            </div>
            
            <div class="tool-group">
                <h3>편집</h3>
                <button id="undo-btn" disabled>실행취소<span class="shortcut">Ctrl+Z</span></button>
                <button id="redo-btn" disabled>다시실행<span class="shortcut">Ctrl+Y</span></button>
            </div>
            
            <div class="tool-group">
                <h3>건축 요소</h3>
                <button id="door-btn" class="icon-btn" title="문 (클릭 또는 드래그)" draggable="true"><svg viewBox="0 0 60 60"><line x1="10" y1="50" x2="50" y2="50" stroke="black" stroke-width="3"/><path d="M 10 50 Q 30 30, 50 50" stroke="black" stroke-width="2" fill="none"/></svg></button>
                <button id="window-btn" class="icon-btn" title="창문 (클릭 또는 드래그)" draggable="true"><svg viewBox="0 0 60 60"><rect x="10" y="25" width="40" height="10" fill="none" stroke="black" stroke-width="2"/><line x1="10" y1="30" x2="50" y2="30" stroke="black" stroke-width="1"/></svg></button>
                <button id="sliding-door-btn" class="icon-btn" title="미닫이문 (클릭 또는 드래그)" draggable="true"><svg viewBox="0 0 60 60"><line x1="10" y1="30" x2="50" y2="30" stroke="black" stroke-width="3"/><rect x="15" y="25" width="15" height="10" fill="none" stroke="black" stroke-width="2"/><rect x="30" y="25" width="15" height="10" fill="none" stroke="black" stroke-width="2"/></svg></button>
                <button id="stairs-btn" class="icon-btn" title="계단 (클릭 또는 드래그)" draggable="true"><svg viewBox="0 0 60 60"><g><line x1="10" y1="15" x2="50" y2="15" stroke="black" stroke-width="1"/><line x1="10" y1="25" x2="50" y2="25" stroke="black" stroke-width="1"/><line x1="10" y1="35" x2="50" y2="35" stroke="black" stroke-width="1"/><line x1="10" y1="45" x2="50" y2="45" stroke="black" stroke-width="1"/><polygon points="25,10 30,20 20,20" fill="black"/></g></svg></button>
            </div>
            
            <div class="tool-group">
                <h3>파일</h3>
                <button id="save-btn">저장</button>
                <button id="load-btn">불러오기</button>
                <button id="export-btn">이미지 내보내기</button>
                <button id="clear-btn">전체 삭제</button>
            </div>
            
            <div class="tool-group">
                <h3>배경 이미지</h3>
                <button id="bg-image-btn">이미지 불러오기</button>
                <button id="bg-clear-btn" disabled>이미지 제거</button>
                <div style="margin-top: 10px; display: none;" id="opacity-control"><label style="font-size: 12px;">불투명도: <input type="range" id="bg-opacity" min="10" max="100" value="50" style="width: 100px; vertical-align: middle;"><span id="opacity-value">50%</span></label></div>
            </div>
            
            <div class="tool-group">
                <h3>보기</h3>
                <button id="grid-btn">격자 표시</button>
            </div>
        </div>
        
        <div class="main-content">
            <div id="canvas-container">
                <canvas id="canvas"></canvas>
                <div class="size-controls" id="size-controls">
                    <!-- ======[업데이트된 코드]====== -->
                    <label id="stroke-width-control">두께: <input type="number" id="stroke-width-input" min="1" step="1"></label>
                    <!-- ============================ -->
                    <label>너비: <input type="number" id="width-input" min="10" step="5"></label>
                    <label>높이: <input type="number" id="height-input" min="10" step="5"></label>
                    <label>각도: <input type="number" id="angle-input" min="0" max="360" step="15"></label>
                </div>
                <div class="history-counter" id="history-counter"></div>
            </div>

            <div id="object-panel">
                <div id="object-panel-header">객체 목록</div>
                <ul id="object-panel-list"></ul>
            </div>
        </div>

        <div class="info">
            <strong>사용법:</strong>
            <ul>
                <li><strong>선 두께 조절: 벽 또는 사각형 선택 시 나타나는 패널에서 두께를 조절합니다.</strong></li>
                <li>화면 이동: 스페이스바를 누른 채 드래그 또는 마우스 휠(가운데 버튼)을 클릭한 채 드래그합니다.</li>
                <li>객체 선택: 캔버스에서 직접 클릭하거나, 우측 '객체 목록' 패널에서 항목을 클릭합니다.</li>
                <li>건축 요소 삽입: 아이콘을 클릭 후 캔버스에 클릭하거나, 아이콘을 캔버스로 드래그 앤 드롭합니다. (드롭 시 화면 중앙에 배치)</li>
                <li>확대/축소: Ctrl 키를 누른 채 마우스 휠을 돌려 조절합니다.</li>
                <li>크기 조절: 객체 모서리를 드래그하여 조절합니다. Shift 키를 누른 채 드래그하면 정비율로 조절됩니다.</li>
                <li>벽/사각형 그리기: 클릭하고 드래그하여 그립니다. (기본 두께 2, 그리기 완료 후 자동 선택 모드 전환)</li>
            </ul>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script>
        const canvasContainer = document.getElementById('canvas-container');
        const canvasEl = document.getElementById('canvas');
        canvasEl.width = canvasContainer.clientWidth;
        canvasEl.height = canvasContainer.clientHeight;

        const canvas = new fabric.Canvas('canvas', { backgroundColor: 'white', selection: true, stopContextMenu: true, fireRightClick: true, uniScaleTransform: true, });

        const history = {
            states: [], currentIndex: -1, maxSize: 50, isRestoring: false,
            saveState() { if (this.isRestoring) return; this.states = this.states.slice(0, this.currentIndex + 1); const state = JSON.stringify(canvas.toJSON(['elementType'])); this.states.push(state); if (this.states.length > this.maxSize) { this.states.shift(); } else { this.currentIndex++; } this.updateButtons(); this.updateCounter(); updateObjectPanel(); },
            undo() { if (this.currentIndex > 0) { this.currentIndex--; this.restore(this.states[this.currentIndex]); } },
            redo() { if (this.currentIndex < this.states.length - 1) { this.currentIndex++; this.restore(this.states[this.currentIndex]); } },
            restore(state) { this.isRestoring = true; const vpt = canvas.viewportTransform; canvas.loadFromJSON(state, () => { canvas.viewportTransform = vpt; canvas.renderAll(); if (showGrid) drawGrid(); updateObjectPanel(); this.isRestoring = false; this.updateButtons(); this.updateCounter(); }); },
            updateButtons() { undoBtn.disabled = this.currentIndex <= 0; redoBtn.disabled = this.currentIndex >= this.states.length - 1; },
            updateCounter() { const counter = document.getElementById('history-counter'); counter.textContent = `${this.currentIndex + 1} / ${this.states.length}`; }
        };

        const gridSize = 20;
        let showGrid = false, currentMode = 'select', isDrawing = false;
        let startX, startY, currentLine = null, selectedObject = null;
        let isPanning = false, lastPosX, lastPosY, spacebarDown = false;
        let backgroundImage = null;
        
        const objectPanelList = document.getElementById('object-panel-list');
        const bgImageBtn = document.getElementById('bg-image-btn'), bgClearBtn = document.getElementById('bg-clear-btn'), bgOpacity = document.getElementById('bg-opacity'), opacityValue = document.getElementById('opacity-value'), opacityControl = document.getElementById('opacity-control');
        const selectBtn = document.getElementById('select-mode'), wallBtn = document.getElementById('wall-mode'), rectBtn = document.getElementById('rect-mode'), textBtn = document.getElementById('text-mode'), deleteBtn = document.getElementById('delete-btn');
        const doorBtn = document.getElementById('door-btn'), windowBtn = document.getElementById('window-btn'), slidingDoorBtn = document.getElementById('sliding-door-btn'), stairsBtn = document.getElementById('stairs-btn');
        const gridBtn = document.getElementById('grid-btn'), undoBtn = document.getElementById('undo-btn'), redoBtn = document.getElementById('redo-btn');
        const sizeControls = document.getElementById('size-controls'), widthInput = document.getElementById('width-input'), heightInput = document.getElementById('height-input'), angleInput = document.getElementById('angle-input');
        
        // ======[업데이트된 코드]======
        const strokeWidthControl = document.getElementById('stroke-width-control');
        const strokeWidthInput = document.getElementById('stroke-width-input');
        const defaultStrokeWidth = 2; // 기본 두께
        // ============================

        history.saveState();

        canvas.on({ 'object:added': () => { if (!history.isRestoring) history.saveState(); }, 'object:modified': () => history.saveState(), 'object:removed': () => { if (!history.isRestoring) history.saveState(); } });

        function createObject(type, x, y) { /* ... */ } // 이전과 동일
        function setMode(mode) { /* ... */ } // 이전과 동일
        
        window.addEventListener('keydown', (e) => { if (e.target.tagName === 'INPUT' || e.repeat) return; if (e.code === 'Space') { e.preventDefault(); spacebarDown = true; if (!isPanning) canvas.setCursor('grab'); } });
        window.addEventListener('keyup', (e) => { if (e.code === 'Space') { e.preventDefault(); spacebarDown = false; if (isPanning && !e.buttons) { isPanning = false; canvas.setCursor('default'); } else if (!isPanning) { canvas.setCursor('default'); } } });
        document.addEventListener('keydown', (e) => { if (e.target.tagName === 'INPUT') return; if ((e.ctrlKey || e.metaKey) && (e.key === 'z' || e.key === 'Z')) { e.preventDefault(); history.undo(); } if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || e.key === 'Y')) { e.preventDefault(); history.redo(); } if (e.key === 'Backspace') { e.preventDefault(); deleteSelectedObjects(); } if (e.key.toLowerCase() === 'v' && !e.ctrlKey) setMode('select'); });

        canvas.on('mouse:wheel', (opt) => { /* ... */ }); // 이전과 동일
        
        canvas.on('mouse:down', (e) => {
            const isMiddleClick = e.e.button === 1; const isSpacebarPan = spacebarDown && e.e.button === 0;
            if (isMiddleClick || isSpacebarPan) { isPanning = true; lastPosX = e.e.clientX; lastPosY = e.e.clientY; canvas.setCursor('grabbing'); canvas.selection = false; return; }
            if (currentMode === 'select' || isDrawing) return;
            const pointer = canvas.getPointer(e.e); startX = pointer.x; startY = pointer.y; isDrawing = true;
            let insertedObject = null;
            switch(currentMode) {
                // ======[업데이트된 코드: 기본 두께 적용]======
                case 'wall': currentLine = new fabric.Line([startX, startY, startX, startY], { stroke: 'black', strokeWidth: defaultStrokeWidth, strokeLineCap: 'square', selectable: false }); canvas.add(currentLine); break;
                // ============================
                case 'text': const text = prompt('텍스트를 입력하세요:'); if (text) { insertedObject = new fabric.Text(text, { left: startX, top: startY, fontSize: 14, fill: 'black' }); canvas.add(insertedObject); } isDrawing = false; break;
                case 'door': case 'window': case 'sliding-door': case 'stairs': insertedObject = createObject(currentMode, startX, startY); if (insertedObject) canvas.add(insertedObject); isDrawing = false; break;
            }
            if (insertedObject) { setMode('select'); canvas.setActiveObject(insertedObject); }
        });
        
        canvas.on('mouse:move', (e) => {
            if (isPanning) { const vpt = canvas.viewportTransform; vpt[4] += e.e.clientX - lastPosX; vpt[5] += e.e.clientY - lastPosY; canvas.requestRenderAll(); lastPosX = e.e.clientX; lastPosY = e.e.clientY; return; }
            if (!isDrawing) return;
            if (currentMode === 'wall' && currentLine) { const pointer = canvas.getPointer(e.e); let endX = pointer.x, endY = pointer.y; if (e.e.shiftKey) { const dx = Math.abs(pointer.x - startX); const dy = Math.abs(pointer.y - startY); if (dx > dy) { endY = startY; } else { endX = startX; } } currentLine.set({ x2: endX, y2: endY }); canvas.renderAll(); }
            else if (currentMode === 'rect' && isDrawing) { const pointer = canvas.getPointer(e.e); const width = Math.abs(pointer.x - startX); const height = Math.abs(pointer.y - startY); if(!currentLine) { currentLine = new fabric.Rect({ left: startX, top: startY, width: 0, height: 0, fill: 'transparent', stroke: 'black', strokeWidth: defaultStrokeWidth, strokeDashArray: [5, 5] }); canvas.add(currentLine); } currentLine.set({ left: Math.min(pointer.x, startX), top: Math.min(pointer.y, startY), width: width, height: height }); canvas.renderAll(); }
        });

        canvas.on('mouse:up', (e) => {
            if (isPanning) { isPanning = false; canvas.selection = (currentMode === 'select'); canvas.setCursor(spacebarDown ? 'grab' : 'default'); return; }
            if (!isDrawing) return;
            let newObject = null;
            if (currentMode === 'wall' && currentLine) { currentLine.set({selectable: true}).setCoords(); newObject = currentLine; } 
            else if (currentMode === 'rect' && currentLine) { canvas.remove(currentLine); const pointer = canvas.getPointer(e.e); const width = Math.abs(pointer.x - startX); const height = Math.abs(pointer.y - startY); if (width > 2 && height > 2) { newObject = new fabric.Rect({ left: Math.min(startX, pointer.x), top: Math.min(startY, pointer.y), width, height, fill: 'transparent', stroke: 'black', strokeWidth: defaultStrokeWidth }); canvas.add(newObject); } }
            if(newObject) { setMode('select'); canvas.setActiveObject(newObject); }
            isDrawing = false; currentLine = null;
        });

        canvas.on({ 'selection:created': (e) => updateSelection(e.selected), 'selection:updated': (e) => updateSelection(e.selected), 'selection:cleared': () => updateSelection([]) });
        
        // ======[업데이트된 코드]======
        canvas.on({ 'object:scaling': updateSizeControls, 'object:rotating': updateSizeControls, 'object:moving': updateSizeControls });

        function updateSelection(selected) { 
            highlightPanelSelection(); 
            selectedObject = selected.length === 1 ? selected[0] : null; 
            if (selectedObject) { 
                sizeControls.classList.add('show'); 
                updateSizeControls(); 
            } else { 
                sizeControls.classList.remove('show'); 
            } 
        }

        function updateSizeControls() {
            if (selectedObject) {
                const isStrokable = selectedObject.type === 'line' || selectedObject.type === 'rect';
                strokeWidthControl.style.display = isStrokable ? 'block' : 'none';

                if (isStrokable) {
                    strokeWidthInput.value = selectedObject.strokeWidth;
                }
                widthInput.value = Math.round(selectedObject.getScaledWidth());
                heightInput.value = Math.round(selectedObject.getScaledHeight());
                angleInput.value = Math.round(selectedObject.angle);
            }
        }
        
        strokeWidthInput.addEventListener('input', () => {
            if (selectedObject && (selectedObject.type === 'line' || selectedObject.type === 'rect')) {
                const newWidth = parseInt(strokeWidthInput.value, 10) || 1;
                selectedObject.set('strokeWidth', Math.max(1, newWidth));
                canvas.renderAll();
            }
        });
        // ============================

        widthInput.addEventListener('input', () => { if (selectedObject) { selectedObject.scaleToWidth(parseInt(widthInput.value, 10)); canvas.renderAll(); }});
        heightInput.addEventListener('input', () => { if (selectedObject) { selectedObject.scaleToHeight(parseInt(heightInput.value, 10)); canvas.renderAll(); }});
        angleInput.addEventListener('input', () => { if (selectedObject) { selectedObject.set('angle', parseInt(angleInput.value, 10)).setCoords(); canvas.renderAll(); }});
        
        selectBtn.addEventListener('click', () => setMode('select')); wallBtn.addEventListener('click', () => setMode('wall')); rectBtn.addEventListener('click', () => setMode('rect')); textBtn.addEventListener('click', () => setMode('text'));
        doorBtn.addEventListener('click', () => setMode('door')); windowBtn.addEventListener('click', () => setMode('window')); slidingDoorBtn.addEventListener('click', () => setMode('sliding-door')); stairsBtn.addEventListener('click', () => setMode('stairs'));
        undoBtn.addEventListener('click', () => history.undo()); redoBtn.addEventListener('click', () => history.redo()); deleteBtn.addEventListener('click', deleteSelectedObjects);
        function deleteSelectedObjects() { canvas.getActiveObjects().forEach(obj => canvas.remove(obj)); canvas.discardActiveObject().renderAll(); }
        
        function updateObjectPanel() {
            objectPanelList.innerHTML = '';
            const objects = canvas.getObjects().filter(obj => !obj.isGridLine);
            objects.forEach((obj, index) => {
                const li = document.createElement('li');
                let name = obj.elementType || obj.type || '객체';
                if(obj.type === 'text') name = `텍스트: ${obj.text.substring(0, 10)}...`;
                else if (obj.type === 'line') name = `벽 ${index + 1}`;
                else if (obj.type === 'rect') name = `사각형 ${index + 1}`;
                else name = `${name.charAt(0).toUpperCase() + name.slice(1)} ${index + 1}`;
                li.textContent = name;
                li.dataset.objectIndex = canvas.getObjects().indexOf(obj);
                li.addEventListener('click', () => { canvas.discardActiveObject(); canvas.setActiveObject(obj).renderAll(); });
                objectPanelList.appendChild(li);
            });
            highlightPanelSelection();
        }

        function highlightPanelSelection() {
            const activeObjects = canvas.getActiveObjects();
            const listItems = objectPanelList.querySelectorAll('li');
            listItems.forEach(li => {
                const objIndex = parseInt(li.dataset.objectIndex, 10);
                const obj = canvas.getObjects()[objIndex];
                li.classList.toggle('selected', activeObjects.includes(obj));
            });
        }

        const draggableElements = ['door-btn', 'window-btn', 'sliding-door-btn', 'stairs-btn'];
        draggableElements.forEach(id => { const el = document.getElementById(id); el.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', id.replace('-btn', '')); }); });
        canvasContainer.addEventListener('dragover', (e) => e.preventDefault());
        canvasContainer.addEventListener('drop', (e) => { e.preventDefault(); const type = e.dataTransfer.getData('text/plain'); const zoom = canvas.getZoom(); const panX = canvas.viewportTransform[4]; const panY = canvas.viewportTransform[5]; const centerX = (canvas.width / 2 - panX) / zoom; const centerY = (canvas.height / 2 - panY) / zoom; const newObject = createObject(type.replace('-',''), centerX, centerY); if (newObject) { canvas.add(newObject); setMode('select'); canvas.setActiveObject(newObject); canvas.renderAll(); } });
        
        document.getElementById('clear-btn').addEventListener('click', () => { /* ... */ }); // 이전과 동일
        bgImageBtn.addEventListener('click', () => { /* ... */ }); // 이전과 동일
        bgClearBtn.addEventListener('click', () => { /* ... */ }); // 이전과 동일
        bgOpacity.addEventListener('input', (e) => { /* ... */ }); // 이전과 동일
        function drawGrid() { /* ... */ } // 이전과 동일
        canvas.on('after:render', () => { if (showGrid) drawGrid(); });
        gridBtn.addEventListener('click', () => { /* ... */ }); // 이전과 동일
        document.getElementById('export-btn').addEventListener('click', () => { /* ... */ }); // 이전과 동일
        document.getElementById('save-btn').addEventListener('click', () => { /* ... */ }); // 이전과 동일
        document.getElementById('load-btn').addEventListener('click', () => { /* ... */ }); // 이전과 동일
        
        // 간소화된 함수들 복원
        function createObject(type, x, y) {
            switch(type) {
                case 'door': const d = new fabric.Group([], { left: x, top: y, originX: 'center', originY: 'center' }); d.addWithUpdate(new fabric.Rect({ left: -40, top: -3, width: 80, height: 6, fill: 'white', stroke: 'black', strokeWidth: 2 })); d.addWithUpdate(new fabric.Path('M -40 0 Q -40 -40, 0 -40', { fill: '', stroke: 'black', strokeWidth: 2 })); d.elementType = 'door'; return d;
                case 'window': const w = new fabric.Group([], { left: x, top: y, originX: 'center', originY: 'center' }); w.addWithUpdate(new fabric.Rect({ left: -30, top: -4, width: 60, height: 8, fill: 'white', stroke: 'black', strokeWidth: 2 })); w.addWithUpdate(new fabric.Line([-30, 0, 30, 0], { stroke: 'black', strokeWidth: 1 })); w.elementType = 'window'; return w;
                case 'slidingdoor': const sd = new fabric.Group([], { left: x, top: y, originX: 'center', originY: 'center' }); sd.addWithUpdate(new fabric.Line([-40, 0, 40, 0], { stroke: 'black', strokeWidth: 3 })); sd.addWithUpdate(new fabric.Rect({ left: -35, top: -5, width: 30, height: 10, fill: 'transparent', stroke: 'black', strokeWidth: 2 })); sd.addWithUpdate(new fabric.Rect({ left: -5, top: -5, width: 30, height: 10, fill: 'transparent', stroke: 'black', strokeWidth: 2 })); sd.elementType = 'slidingdoor'; return sd;
                case 'stairs': const st = new fabric.Group([], { left: x, top: y, originX: 'center', originY: 'center' }); for (let i = 0; i < 6; i++) { st.addWithUpdate(new fabric.Line([-30, -25 + i * 10, 30, -25 + i * 10], { stroke: 'black', strokeWidth: 1 })); } st.addWithUpdate(new fabric.Polygon([{x: 0, y: -35}, {x: -5, y: -25}, {x: 5, y: -25}], { fill: 'black' })); st.elementType = 'stairs'; return st;
            }
        }
        function setMode(mode) { currentMode = mode; document.querySelectorAll('button.active').forEach(btn => btn.classList.remove('active')); const currentBtn = document.getElementById(mode + '-mode') || document.getElementById(mode + '-btn'); if (currentBtn) currentBtn.classList.add('active'); canvas.selection = mode === 'select'; canvas.forEachObject(obj => { if (!obj.isGridLine) obj.selectable = (mode === 'select'); }); canvas.renderAll(); }

        setMode('select');
    </script>
</body>
</html>
